<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算CPU利用率]]></title>
    <url>%2F41872%2F</url>
    <content type="text"><![CDATA[CPU的使用率其实是一段时间内的统计数据，按照定义，某个进程的CPU使用率是指该进程在一个时间段内消耗的CPU时间与该时间段长度的比值。所以选择不同的时间间隔，得到的结果是不同的。 在Windows系统下，我们可以用 GetSystemTimes 、GetProcessTimes 等API获得一个时间段内的CPU时间。下面结合使用体会说明如何计算系统CPU使用率。 1.计算原理系统将时间以时间片的形式分配给CPU，时间片是系统的最小时间单位，在一个时间片内CPU可能在处理用户程序，可能在处理系统程序，也可能处于空闲状态，我们只要统计在一段时间内空闲的总时间与工作的总时间，就能得到这段时间的CPU平均使用率。 在Windows系统中，系统启动后就会记录每个时间片的状态，并存放在内存的变量中。假如系统在内存中有3个变量：Parameter_Idle，Parameter_Kernel，Parameter_User，则这三个变量分别记录了从系统启动开始到当前的各个时间片的累加值，即Parameter_Idle记录了从系统开始到当前的总的空闲时间片数，Parameter_Kernel记录了从系统开始到当前的总的KernelMode状态的时间片数。 如图上标识，在Start时间点获取一次系统的当前各个状态的时间片数，在End时间点再次获取一次系统的当前各个状态的时间片数。两个时间点获取的各个状态的时间片数量的差值，然后 \frac{总的工作时间}{总的空闲时间+总的工作时间} \times {100}就是统计时间内，CPU的使用率 2.C++代码123456789101112131415161718192021222324252627282930313233343536373839static float CalculateCPULoad(unsigned long long idleTicks, unsigned long long totalTicks)&#123; static unsigned long long _previousTotalTicks = 0; static unsigned long long _previousIdleTicks = 0; unsigned long long totalTicksSinceLastTime = totalTicks - _previousTotalTicks; unsigned long long idleTicksSinceLastTime = idleTicks - _previousIdleTicks; float ret = 1.0f - ((totalTicksSinceLastTime &gt; 0) ? ((float)idleTicksSinceLastTime) / totalTicksSinceLastTime : 0); _previousTotalTicks = totalTicks; _previousIdleTicks = idleTicks; return ret;&#125;static unsigned long long FileTimeToInt64(const FILETIME &amp; ft) &#123; return (((unsigned long long)(ft.dwHighDateTime)) &lt;&lt; 32) | ((unsigned long long)ft.dwLowDateTime); &#125;float GetCPULoad()&#123; FILETIME idleTime, kernelTime, userTime; return GetSystemTimes(&amp;idleTime, &amp;kernelTime, &amp;userTime) ? CalculateCPULoad(FileTimeToInt64(idleTime), FileTimeToInt64(kernelTime) + FileTimeToInt64(userTime)) : -1.0f;&#125;void main()&#123; float cpu=0; while (true) &#123; Sleep(1000);//统计1s内的CPU平均使用率 cpu = 100 * GetCPULoad(); &#125;&#125;]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>任务管理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念网易博客关闭]]></title>
    <url>%2F54954%2F</url>
    <content type="text"><![CDATA[是时候说再见了！但回忆会留下来网易博客要关闭啦，以后就全力运作LOFTER轻博客了，在上面写的东西看了一下、回忆了一下，把其中一些导出来吧。 一本精美的年度总结目前还是能够访问的]]></content>
  </entry>
  <entry>
    <title><![CDATA[自动操作Android手机]]></title>
    <url>%2F46349%2F</url>
    <content type="text"><![CDATA[现在的小视频软件为了增加用户也是操碎了心，南抖音北快手、火山西瓜满地走、微视也来插一手。留住用户最直接的方式就是发红包啦。但是为了那几毛几分钱一直去刷视频，显然不合适呀，还有工作要做呀。 为了愉快的褥羊毛，我写了一个自动脚本，让软件去帮我刷视频吧 😂😂😂 主要就是使用ADB工具(点我下载ADB)，配合bat脚本，定时执行模拟滑动操作input swipe 在同一个局域网中，用无线调试的方式最方便啦。脚本很简单，就是一个定时器里执行adb.exe程序，用python、C、VB做定时器也可以，只是bat最简单啦。 就这么几行代码： 12345678910111213@echo offadb tcpip 5555 #无线模式，端口5555adb connect 192.168.1.110 #手机IPchoice /t 2 /d y /n &gt;nul #延时2秒:startset /a m=%random%set /a m=m%%20+10echo %date%%time%--delay:%m%adb shell input swipe 540 1300 540 500 300 #模拟滑动choice /t %m% /d y /n &gt;nul #随机延时，反反作弊goto start 如果无线方式无法连接手机，可以先用USB方式连接，执行 adb usb 连击手机，然后再 adb tcpip 5555 切换成无线方式。另外记得手机上要开启调试模式。 效果如下,bat的定时器不太准，大概3秒滑动一次： 更新：双十一自动盖楼双十一新玩法，浏览商品页获得金币去盖楼。那手动刷太浪费时间了，所以要写个脚本。 这次用 Linux 的 sh 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748adb tcpip 5555adb connect 192.168.1.111sleep 1while truedo echo `date` echo "1" adb shell input tap 896 1096 sleep 4 adb shell input swipe 200 1000 200 200 200 sleep 20 adb shell input keyevent 4 sleep 4 echo "2" adb shell input tap 896 1282 sleep 4 adb shell input swipe 200 1000 200 200 200 sleep 20 adb shell input keyevent 4 sleep 4 echo "3" adb shell input tap 896 1472 sleep 4 adb shell input swipe 200 1000 200 200 200 sleep 20 adb shell input keyevent 4 sleep 4 echo "4" adb shell input tap 896 1655 sleep 4 adb shell input swipe 200 1000 200 200 200 sleep 20 adb shell input keyevent 4 sleep 4 echo "5" adb shell input tap 896 1844 sleep 4 adb shell input swipe 200 1000 200 200 200 sleep 20 adb shell input keyevent 4 sleep 4done 主要流程就是 “点击一个按钮进入页面——-停留一段时间——返回” 这样依次点击领金币页面的所有的按钮。模拟人去一个一个点。 有一点就是要自己先获取到每个按钮的坐标，也很简单。手机截屏，然后用电脑自带的画图工具打开，鼠标在图片上滑动时，状态栏就会显示坐标啦。上面的代码时我1080*2160的分辨率下获取的按钮坐标。 为了方便团队使用，另外用MFC做了一个版本，可以USB、WiFi两种连接方式.下载地址：(盖楼GUI)]]></content>
      <tags>
        <tag>adb</tag>
        <tag>bat</tag>
        <tag>模拟滑动</tag>
        <tag>双十一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑死我了]]></title>
    <url>%2F16727%2F</url>
    <content type="text"><![CDATA[这世道难的…… 妈妈语重心长的对女儿说，“从小你就不聪明，累死累活的才考上大学，毕业后还找不到工作，现在司机要男的、编辑要男的、会计要男的、连秘书 也要男的，妈实在为你操碎了心啊。” 女儿“555。。。” 妈妈一抹脸，坚定的说，“所以趁现在老婆还能是女人，赶紧上岗，要不然过两年……”]]></content>
      <categories>
        <category>网易博客</category>
      </categories>
      <tags>
        <tag>网易</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摩斯码发报机]]></title>
    <url>%2F43145%2F</url>
    <content type="text"><![CDATA[有人说要用发报机和我聊天，只好用树莓派做一个发报机啦。 参照了这个代码通过树莓派发送摩斯码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778## 编码##import RPi.GPIO as GPIOimport timeCODE = &#123;'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', &#125;pin = 40GPIO.setmode(GPIO.BOARD)GPIO.setup(pin, GPIO.IN,pull_up_down=GPIO.PUD_DOWN)on_count=0off_count=0inputchar=""inputcode=""flag=0while (1): if GPIO.input(pin)==1 : while (1) : on_count += 1 time.sleep(0.01) if GPIO.input(pin)==1 : on_count += 1 off_count=0 else: off_count += 1 if off_count &gt; 50 : break if on_count&lt;80 : print('.') inputcode+='.' else: print('-') inputcode+='-' on_count=0 off_count=0 time.sleep(0.01) off_count += 1 if off_count &gt; 200: off_count=0 print("input code: ",inputcode) for c in CODE: if inputcode==CODE[c]: inputchar=c flag=1 break if flag==1: print("input char: ",inputchar) flag=0 else: print("Invalid code!!!!") flag=0 inputchar="" inputcode="" while (1) : if GPIO.input(pin)==1 : break 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051## 解码##import RPi.GPIO as GPIOimport timepin = 40GPIO.setmode(GPIO.BOARD)GPIO.setup(pin, GPIO.OUT)CODE = &#123;'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', &#125;DOT_LENGTH = 0.3 # seconds value for dot '.'while (1): message = input("input a word: ") morse_code = "" for c in message: GPIO.output(pin, 0) #time.sleep(DOT_LENGTH * 3) # pause between characters if c == ' ': morse_code += ' ' time.sleep(DOT_LENGTH * 7) # pause between words else: for code in CODE[c.upper()]: morse_code += code time.sleep(DOT_LENGTH) # pause between code elements if code == '.': GPIO.output(pin, 1) time.sleep(DOT_LENGTH) # pause between dots else: GPIO.output(pin, 1) time.sleep(DOT_LENGTH * 3) # pause between dashes GPIO.output(pin, 0) morse_code +=' ' print("morse: ",morse_code) 用高电平接触pin40就能发报了 看一下发报机的效果吧]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>摩斯码</tag>
        <tag>发报机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派内核编译及编写驱动]]></title>
    <url>%2F28454%2F</url>
    <content type="text"><![CDATA[从树莓派Git库这里下载树莓派的内核源码linux 、编译工具tools和fireware固件。将源码解压，查看一下最外层的Makefile，里面有几个字段需要注意 ARCH CROSS_COMPILE ARCH表示要编译的平台架构，在/arch目录下存放了硬件平台的内容，每一个平台占用一个目录，由于在树莓派下，所以ARCH=arm CROSS_COMPILE表示用到的编译器的前缀，在下载的编译工具下有4种编译工具，选择其中的一个，比如～/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf- 。这个路径比较长，可以定义一个变量 export CCPREFIX=～/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf- 1.开始编译内核 ​ make需要用到包含一系列配置信息的.config文件，该文件可以用make config命令生成。一般从正在运行的树莓 派上/proc/config.gz解压出config文件，改名为.config。 make ARCH=arm CROSS_COMPILE=$CCPREFIX -jn+1 -j(n+1) 表示多核处理器下用n个核来编译，越多越快。 make ARCH=arm CROSS_COMPILE=$CCPREFIX bzImage 生成zImage Image vmlinux 经测试都能引导启动。也可以用tools下的imagemake工具把上面的镜像解压成kernel.img。 make bzImage段在相应的平台目录下的Makefile，已经不在支持zImage命令 生成的zImage为压缩的内核，Image为非压缩的内核 make ARCH=arm CROSS_COMPILE=$CCPREFIX modules 生成模块，若出现错误重新配置.config，关掉出错的模块。 make ARCH=arm CROSS_COMPILE=$CCPREFIX modules_install INSTALL_MOD_PATH=(modules path) 将模块安装到 INSTALL_MOD_PATH 下，若没有指定，将会默认安装到/lib目录下，如图 在INSTALL_MOD_PATH下会生成/lib/modules和/lib/fireware 至此，内核编译完成。将内核镜像放到 /boot 下，将/lib/modules和/lib/fireware放到/lib下。也可以再将fireware固件下的/boot/bootcode.bin /boot/fixup.dat /boot/start.elf 放到/boot下，把/opt下的vc 替换 /opt的vc（判断是硬浮点还是软浮点） 2.自定义驱动模块编译 hello world驱动 123456789101112131415161718// hello.c#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;MODULE_LICENSE("GPL");static int hello_init(void)&#123; printk(KERN_ALERT "hello world!\n"); return 0;&#125;static void hello_exit(void)&#123; printk(KERN_ALERT "goodbye!\n");&#125;module_init(hello_init);module_exit(hello_exit); Makefile文件 12345678910111213141516# example of driver module on armifneq ($(KERNELRELEASE),)obj-m := hello.oelse KDIR := ~/linux-rpi-3.12.y/ PWD = $(shell pwd) CCPREFIX=~/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-all: make -C $(KDIR) M=$(PWD) modules ARCH=arm CROSS_COMPILE=$(CCPREFIX)clean: rm -f *.ko *.o *.mod.o *.mod.c *.symvers modul* *~ endif make进行编译，编译成功后用 file 命令检查hello.ko的属性是否为arm类型。 模块加载成功会在dmesg下显示。 KDIR也可以为~/linux-rpi-3.12.y/INSTALL_MOD_PATH/lib/modules/3.12.36/build，实际上这和~/linux-rpi-3.12.y/是一样的，因为~/linux-rpi-3.12.y/INSTALL_MOD_PATH/lib/modules/3.12.36/build是一个软连接，又链接到~/linux-rpi-3.12.y/。这只是在有源码的时候才用的路径。如果在电脑上编译本机驱动时，因为没有源码包，而/usr/src下面的源码存在，这时软连接会链接到这里。]]></content>
      <categories>
        <category>网易博客</category>
      </categories>
      <tags>
        <tag>网易</tag>
        <tag>linux</tag>
        <tag>树莓派</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎新管理员]]></title>
    <url>%2F55061%2F</url>
    <content type="text"><![CDATA[这个网站新来的管理员有点凶🐻 具体怎么样子凶，参照下面 是不是不好惹。]]></content>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测量精度与分辨率的区别]]></title>
    <url>%2F30414%2F</url>
    <content type="text"><![CDATA[比如一把尺子，最小刻度是1mm，它的分辨率就是1mm。但是尺子上的1mm到底准不准呢？与1mm的标准长度的差值，就是精度。 举一对例子：一把尺子，最小刻度是1m，但是这个1m的刻度定的非常准确，与1m的标准长度只有±1mm的误差。那么这把尺子的分辨率是1m，但是测量精度是1mm。就是说用这把尺子量，最小只能量出1m，再往上就是2m，3m，没有中间值。但是量出来的这1m长度非常精确，其真实长度最小是0.99m，最大是1.01m. 而另一把尺子，最小刻度是0.5m，但是这个0.5m刻度定的很粗糙，与0.5m的标准长度有±0.3m的误差。则这把尺子分辨率是0.5m，而测量精度是0.3m。即用这把尺子量，最小可以量出0.5m的长度，往上就是1m，1.5m，没有中间值。但是由于其精度差，量出来的0.5m，其真实长度最小可能是0.5-0.3=0.2m，最大则是0.8m。]]></content>
  </entry>
  <entry>
    <title><![CDATA[清空输入缓冲区]]></title>
    <url>%2F24236%2F</url>
    <content type="text"><![CDATA[1.为什么 fflush(stdin) 是错的？首先请看以下程序： 123456789101112#include &lt;stdio.h&gt;int main( void )&#123; int i; for (;;) &#123; fputs("Please input an integer: ", stdout); scanf("%d", &amp;i); printf("%d\n", i); &#125; return 0;&#125; ​ 这个程序首先会提示用户输入一个整数，然后等待用户输入，如果用户输入的是整数，程序会输出刚才输入的整数，并且再次提示用户输入一个整数，然后等待用户 输入。但是一旦用户输入的不是整数（如小数或者字母），假设 scanf 函数最后一次得到的整数是 2 ，那么程序会不停地输出“Please input an integer: 2”。这是因为 scanf(“%d”, &amp;i); 只能接受整数，如果用户输入了字母，则这个字母会遗留在“输入缓冲区”中。因为缓冲中有数据，故而 scanf 函数不会等待用户输入，直接就去缓冲中读取，可是缓冲中的却是字母，这个字母再次被遗留在缓冲中，如此反复，从而导致不停地输出“Please input an integer: 2”。 也许有人会说：“居然这样，那么在 scanf 函数后面加上‘fflush(stdin);’，把输入缓冲清空掉不就行了？”然而这是错的！ C和C++的标准里从来没有定义过 fflush(stdin)。​ 也许有人会说：“可是我用 fflush(stdin) 解决了这个问题，你怎么能说是错的呢？”​ 的确，某些编译器（如VC6）支持用 fflush(stdin) 来清空输入缓冲，但是并非所有编译器都要支持这个功能（linux 下的 gcc 就不支持），因为标准中根本没有定义 fflush(stdin)。MSDN 文档里 也清楚地写着fflush on input stream is an extension to the C standard（fflush 操作输入流是对 C 标准的扩充）。当然，如果你毫不在乎程序的移植性，用 fflush(stdin) 也没什么大问题。以下是 C99 对 fflush 函数的定义： int fflush(FILE *stream) ​ 如果 stream 指向输出流或者更新流（update stream），并且这个更新流最近执行的操作不是输入，​ 那么 fflush 函数将把这个流中任何待写数据传送至宿主环境（host environment）写入文件。否则，它的行为是未定义的。 原文如下： int fflush(FILE *stream);If stream points to an output stream or an update stream in which the most recent operation was not input, the fflush function causes any unwritten data for that stream to be delivered to the host environmentto be written to the file; otherwise, the behavior is undefined. 其中，宿主环境可以理解为操作系统或内核等。 由此可知，如果 stream 指向输入流（如 stdin），那么 fflush 函数的行为是不确定的。故而使用 fflush(stdin)是不正确的，至少是移植性不好的。 2.清空输入缓冲区的方法​ 虽然不可以用 fflush(stdin)，但是我们可以自己写代码来清空输入缓冲区。只需要在 scanf 函数后面加上几句简单的代码就可以了。 123456789101112131415161718192021222324252627/* C 版本 */#include &lt;stdio.h&gt;int main( void )&#123; int i, c; for ( ; ; ) &#123; fputs("Please input an integer: ", stdout); scanf("%d", &amp;i); if ( feof(stdin) || ferror(stdin) ) &#123; /* 如果用户输入文件结束标志（或文件已被读完）， */ /* 或者发生读写错误，则退出循环 */ /* do something */ break; &#125; /* 没有发生错误，清空输入流。 */ /* 通过 while 循环把输入流中的余留数据“吃”掉 */ while ( (c = getchar()) != '\n' &amp;&amp; c != EOF ) ; /* 使用 scanf("%*[^\n]"); 也可以清空输入流， */ /* 不过会残留 \n 字符。 */ printf("%d\n", i); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334/* C++ 版本 */#include &lt;iostream&gt;#include &lt;limits&gt; // 为了使用numeric_limitsusing namespace std;int main()&#123; int value; for ( ; ; ) &#123; cout &lt;&lt; "Enter an integer: "; cin &gt;&gt; value; if ( cin.eof() || cin.bad() ) &#123; // 如果用户输入文件结束标志（或文件已被读完）， // 或者发生读写错误，则退出循环 // do something break; &#125; // 读到非法字符后，输入流将处于出错状态， // 为了继续获取输入，首先要调用 clear 函数 // 来清除输入流的错误标记，然后才能调用 // ignore 函数来清除输入流中的数据。 cin.clear(); // numeric_limits&lt;streamsize&gt;::max() 返回输入缓冲的大小。 // ignore 函数在此将把输入流中的数据清空。 // 这两个函数的具体用法请读者自行查询。 cin.ignore( numeric_limits&lt;streamsize&gt;::max(), '\n' ); cout &lt;&lt; value &lt;&lt; '\n'; &#125; return 0;&#125; 参考资料：ISO/IEC 9899:1999 (E) Programming languages— C 7.19.5.2 The fflush functionThe C Programming Language 2nd Edition By Kernighan &amp; RitchieISO/IEC 14882(1998-9-01)Programming languages — C++]]></content>
      <categories>
        <category>网易博客</category>
      </categories>
      <tags>
        <tag>网易</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>fflush</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灰度图像的腐蚀膨胀操作原理]]></title>
    <url>%2F37744%2F</url>
    <content type="text"><![CDATA[形态学操作一般是对二值图像的操作，但是在MATLAB中，灰度图像也有形态学处理。其原理为 结论：平坦的灰度膨胀是一个局部最大值算子。 结论：平坦的灰度腐蚀是一个局部最小值算子。]]></content>
      <categories>
        <category>网易博客</category>
      </categories>
      <tags>
        <tag>网易</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建mqtt服务器broker]]></title>
    <url>%2F20952%2F</url>
    <content type="text"><![CDATA[由于项目需要，对远程的电脑运行参数进行监控。之前接触过mqtt物联网协议，觉得用publish、subscribe的方式能够满足项目需求，并且部署简单，因此搭建了一台Mosquitto broker。默认的Mosquitto是不支持websockets的，为了使大家都能方便的监控数据，我采用了网页作为subscribe客户端，这样就要开启mosquitto的websockets功能。下面是主要搭建步骤： 服务器系统为：Ubuntu 18.04 x64 第一篇 搭建mqtt broker1.安装依赖项需要 openssl、libwebsockets 12sudo apt install libssl-devsudo apt install libwebsockets-dev 2.下载并修改配置进行编译在官网下载源码 wget https://mosquitto.org/files/source/mosquitto-1.6.0.tar.gz 或者去GitHub下载git clone https://github.com/eclipse/mosquitto.git 解压后修改config.mk文件，开启websockets 12# Build with websockets support on the broker.WITH_WEBSOCKETS:=yes 然后直接 make,make install 3.配置并开启服务mosquitto支持多个端口，每个端口可以配置不同的协议，默认在1883端口监听mqtt访问。修改源文件中的mosquitto.conf文件 123456789101112131415161718192021222324# ================# Default listener# ================#在本段监听mqtt协议# Port to use for the default listener.port 1883# Choose the protocol to use when listening.# This can be either mqtt or websockets.# Websockets support is currently disabled by default at compile time.# Certificate based TLS may be used with websockets, except that# only the cafile, certfile, keyfile and ciphers options are supported.protocol mqtt# =================# Extra listeners# =================#在本段监听websockets协议# listener port-number [ip address/host name]listener 1884# Choose the protocol to use when listening.# This can be either mqtt or websockets.# Certificate based TLS may be used with websockets, except that only the# cafile, certfile, keyfile and ciphers options are supported.protocol websockets 然后将mosquitto.conf文件放到某个路径（比如/etc/mosquitto.conf） 启动mosquitto 1mosquitto -c /etc/mosquitto.conf 至此一个简单的mqtt broker就建好了 第二篇 publish subscribe 测试1.远程电脑端publish运行参数为了轻巧，远程端采用c语言编写，用到paho的C库，主要过程如下，不停的向broker发送数据，当有subscriber时，broker就把数据转发给subscriber，类似于远端电脑向全网广播。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int _stdcall WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)&#123; MQTTClient client; MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer; MQTTClient_message pubmsg = MQTTClient_message_initializer; MQTTClient_deliveryToken token; while (true) &#123; MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL); conn_opts.keepAliveInterval = 20; conn_opts.cleansession = 1; while (MQTTClient_connect(client, &amp;conn_opts) != MQTTCLIENT_SUCCESS) &#123; printf("Failed to connect\n"); &#125; pubmsg.payload = PAYLOAD; pubmsg.payloadlen = strlen(PAYLOAD); pubmsg.qos = QOS; pubmsg.retained = 0; printf("publishing hello world....\n"); char msg[50] = "\0"; while (1) &#123; MQTTClient_publishMessage(client, TOPIC, &amp;pubmsg, &amp;token); if (MQTTCLIENT_SUCCESS != MQTTClient_waitForCompletion(client, token, TIMEOUT)) &#123; break; &#125; Sleep(SLEEPTIME); msg=GetPCLoad(); pubmsg.payload = msg; pubmsg.payloadlen = strlen(msg); &#125; MQTTClient_disconnect(client, 10000); MQTTClient_destroy(&amp;client); &#125; return 0;&#125; 2.网页端subscribe同样用到paho的js库，主要过程为 1234567client = new Paho.MQTT.Client(host,port,path,Math.random().toString(16).substr(2));client.connect(&#123;onSuccess:onConnect&#125;);client.onMessageArrived = onMessageArrived;function onMessageArrived(message) &#123; parse message； plot data；&#125; 当数据到来时，用echart图表的方式实现可视化。效果如图 注意 IE浏览器不支持websocket，要用chrome内核的浏览器]]></content>
      <tags>
        <tag>mqtt</tag>
        <tag>Mosquitto</tag>
        <tag>echart</tag>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把博客迁移到GitHub]]></title>
    <url>%2F42373%2F</url>
    <content type="text"><![CDATA[由于众所周知的原因，腾讯云，阿里云，AWS，谷歌云等都不能用了（其实是不能白嫖了），无奈只能给博客搬个家了，去免费的地方画圈圈。大名鼎鼎的Github自从被微软收购后，私有库也开始免费了，这对白嫖人士来说是极好的，而且我的博客是用hexo建立的静态博客，所以我就愉快的决定去Github的page服务上安家了。过程也蛮简单的，总共分两步： 第一步，建立仓库建立一个私有库私有库用来存放hexo服务框架以及你的文章稿件。那如果你在本地保存或者在其他的地方保存或者已经保存在了github，那么这个仓库就不用再建了。 建立一个公开库公开库用来存放生成的网页文件，开启page服务（page服务只能再公开库上有效）。给公开库起一个响当当的名字，比如钉宫病患者🐶😏建好库后就可以在hexo的配置文件_config.yml里填写库的地址以便自动部署 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/yourname/you_are_hentai.git branch: master 然后写完文章后用hexo g命令生成网页，然后再用hexo d将网页上传到公开库。或者你不用自动部署，可以手动将public文件夹里的所有文件push到公开库。这样网页就写好了，接下来就是在GitHub上配置网站了。 第二步，配置page服务打开你的公开库的setting页面，往下翻，找到GitHub Pages板块，在source里选择master branch，然后你就会得到一个网址，这样你的网站就建好啦。快去访问你的网站试试吧。 进阶篇你发现你的网址很长，http://www.yourname.github.io/you_are_hentai 很不上档次，别人都是 http://www.yourname.github.io，那怎么办呢？很简单，把你的公开库改个名字，改成你的用户名.github.io，比如这样你的网址就变成了高大上的 http://www.yourname.github.io 啦。 如果你有域名的话，还可以改成自己的域名。在GitHub Pages板块的Custom domain里面写上你的域名就可以啦，保存后刷新一下就可以用 www.yourdomain.com 访问网站啦。 为了访问速度，腾讯的coding很不错 https://dev.tencent.com]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提取网页中的视频]]></title>
    <url>%2F17875%2F</url>
    <content type="text"><![CDATA[最近有很多小朋友跟我说，在网页上看到好看的视频，想下载下来，但是网页上没有下载的选项，右键另存为也不行，该怎么办呢？ 那我就教给他们一个我常用的方法。 以前的网页视频可以直接在视频上点击右键另存为就可以保存到电脑上了，现在的网页播放器都会隐藏视频的真实地址，右键另存为不能用了。或者把视频切成很多小碎片，一次下载只能得到几秒的视频内容。 我这个方法是用网页调试工具找到视频的真实地址，是通用的。但是对于优酷，爱奇艺这样的采用防盗链技术的是无效的，能找到视频切片的地址，但是没有权限下载，需要更高级的解析方案。 1.首先需要一个chrome内核的浏览器我相信大部分人都用的chrome也就是谷歌浏览器，简洁快速好用。开发人员也特别喜欢它，因为里面有console调试工具，用来调试网页简直棒棒哒。一般只要是chrome内核的浏览器都会有这个调试工具的。 2.打开console工具在网页的空白区域点击右键选择检查，调出console。或者直接按F12调出来。 3.查看资源刷新网页，获取所有资源链接把console切换到Network选项卡，这里会记录网页使用到的所有资源文件。刷新一下网页，就会看到Network选项卡里出现很多链接。这里每一个链接就对应浏览器加载这个网页所下载的一个文件。 找到可能是视频的链接找一下其中包含视频的链接，一般地址里会有mp4、flv、ts等后缀名。因为视频文件一般是比较大的，所以看加载时间Time最长的，或者瀑布流Waterfall最长的那几个，可能就是视频了。或者看类型Type为media的，也是视频。 在另一个窗口打开视频链接找到可能是视频的链接后，点击一个这个链接就会出现详细的请求信息，请求头Header里的Request URL就是视频的真是地址了。在其他页面打开这个地址就能看到视频啦。然后就可以用右键另存为的方式下载啦。 视频演示下面这个视频是用我讲的这个方法下载微博的视频]]></content>
      <tags>
        <tag>视频解析</tag>
        <tag>提取下载链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[娱乐一下]]></title>
    <url>%2F16060%2F</url>
    <content type="text"><![CDATA[有则改之无则加勉 No.1市政府近日开会，讨论关于取缔小姐的问题，小姐代表在会上发言： 一不偷，二不抢，三不反对党（公安局长表态：行） 不占地，不占房，工作只要一张床（国土局长高兴地说：好） 不生女，不生男，不给政府添麻烦（计生办主任点头：不错） 无噪声，无污染，只是偶尔喊一喊（环保局长说：喊吧喊吧） 不集资，不贷款，自带设备搞发展（发改委主任：欢迎欢迎） 下岗妹，不流泪，就业自己找机会（社保局长不住地说：对对对） 不逃税，不欠费，挣多挣少无所谓（税务局长满意地说：可贵啊可贵） 不嫌脏，不怕累，拉动内需创外汇（外经贸局长伸出大拇指：够意思） 不惹祸，不胡扯，坚决不做第三者（妇联主席很欣慰地说：省心啊） 不怕打，不怕捶，坚决不说陪过谁（纪检书记直点头说:好，组织纪律性很强嘛） 不跟风，不涨价，稳定市场责任大（物价局长感激涕零的说：默默奉献为稳定，谢谢呀） No.2女警察为婴儿喂奶被提为公安局副政委众多女警跑到北京投诉：局里领导吃我们的奶都好几年了，啥官也没给。组织部长说了三点：1。奶虽一样，但人家的奶里有奶水你们有吗2。人家喂奶群众都看见了，还上了电视，你们给领导喂奶谁看见了？3。小孩吃奶是主食，大人吃奶是零食，能一样吗. No.3领导昨晚喝醉，搂着小姨子睡，惹得家人直责备。岳父说：两瓶啤酒怎能醉？分明思想错了位！岳母说：好在都是一家人，若是别人要收费！妻子说：我的服务很到位，再睡小妹累不累？领导说：我睡小妹是不对，都是酒精惹我醉，大家批评都是对，今后不再睡小妹！小妹说：你们操心累不累，只管自己男女睡，哪管小女啥体会，夜夜听到叫床声，害我整夜难入睡，还是姐夫理解我，昨夜初尝爱滋味，可异一夜时间短，很多姿势没到位，我不生小孩不篡位，别让资源白浪费，你们不要乱责备，有福同享没有罪，家庭和谐第一位，共创文明新社会 No.41 姑娘们啊！哪有那麽多白马啊？找个驴凑合得了，别等到有一天驴都被抢没了，剩一堆骡子…2 所谓美女，三分长相七分打扮、所谓气质，三分才气七分装蒜、所谓温柔，三分忍让七分压抑。3 下辇子要做筷子，就不孤单了！4 你的话，我连标点符号都不信。5 此处不留爷，自有留爷处。处处不留爷，爷回家做家务。6 铁公鸡还会留点儿铁锈呢，你根本就是个不锈钢公鸡！7 陪我一起数星星吧，你智商低你就数月亮吧！8 我太佩服我自己了，有时候照镜子的时候都给自己磕头！9 最有魅力的人是“康师傅”天都有成千上万的人泡他。10 想你想得饭都吃不下，真是太恶心了！11 其实我以前个子挺高的，只不过后来经常洗澡缩水了而已。12 为什麽我一直感觉不幸福，难道是当幸福来敲门的时候，我不在家1、干掉熊猫，我就是国宝！2、别和我谈理想，戒了！3、跌倒了，爬起来再哭4、低调！才是最牛B的炫耀！！5、不吃饱哪有力气减肥啊？6、真不好意思，让您贱笑了。7、我能抵抗一切，除了诱惑……8、老子不但有车，还是自行的……9、点的是烟、抽的却是寂寞……10、不是你不笑，一笑粉就掉！11、人又不聪明，还学别人秃顶。12、绑不住我的心就不要说我花心！13、再牛b的肖邦，也弹不出老子的悲伤！14、活着的时候开心点，因为我们要死很久。15、请你以后不要在我面前说英文了，OK？16、我这人从不记仇，一般有仇当场我就报了。17、没什么事不要找我，有事更不用找我！18、我那么喜欢你，你喜欢我一下会死啊?19、我又不是人民币，怎么能让人人都喜欢我？20、男人的话就像老太太的牙齿，有多少是真的？！21、问：你喜欢我哪一点？答：我喜欢你离我远一点！22、执子之手，方知子丑，泪流满面，子不走我走。23、诸葛亮出山前，也没带过兵！凭啥我就要工作经验？24、珍惜生活——上帝还让你活着，就肯定有他的安排。25、雷锋做了好事不留名，但是每一件事情都记到日记里面。26、师太，你是我心中的魔，贫僧离你越近，就离佛越远……27、初中的体育老师说：谁敢再穿裙子上我的课，就罚她倒立。28、自己选择45°仰视别人，就休怪他人135°俯视着看你。29、如果你看到面前的阴影，别怕，那是因为你的背后有阳光！30、我允许你走进我的世界，但绝不允许你在我的世界里走来走去。31、人永远不知道谁哪次不经意的跟你说了再见之后就真的再也不见了。32、一分钟有多长？这要看你是蹲在厕所里面，还是等在厕所外面……33、爱，就大声说出来，因为你永远都不会知道，明天和意外，哪个会先来！34、你永远看不到我最寂寞的时候，因为在看不到你的时候就是我最寂寞的时候！35、听说女人如衣服，兄弟如手足，回想起来，我竟然七手八脚地裸奔了二十多年！36、今天心情不好，我只有四句话想说，包括这句和前面的两句，我的话说完了！37、铁饭碗的真实含义不是在一个地方吃一辈子饭，而是一辈子到哪儿都有饭吃。38、就算是一坨屎，也有遇见屎壳郎的那天。所以你大可不必为今天的自己有太多担忧。39、如果中了一千万，我就去买30套房子租给别人，每天都去收一次房租。哇咔咔~ 充实！40、“恋”是个很强悍的字。它的上半部取自“变态”的“变”，下半部取自“变态”的“态”。41、再过几十年，我们来相会，送到火葬场，全部烧成灰，你一堆，我一堆，谁也不认识谁，全部送到农村做化肥。42、我爸说过的最让我感动的一句话：“孩子，好好学习吧，爸以前玩麻将都玩儿10块的，现在为了供你念书，改玩儿1块的了。”43、同志们：别炒股，风险太大了，还是做豆腐最安全！做硬了是豆腐干，做稀了是豆腐脑，做薄了是豆腐皮，做没了是豆浆，放臭了是臭豆腐！稳赚不亏呀！ No.5 赵本山上场说：“ 车到山前必有路，可惜丰田刹不住！ 丰田就是刹的住，吓得车主尿一裤！ 开上丰田雅力士，重症病房把伤治！ 买了丰田凯美瑞、太平间里安心睡！ 三轮丰田好，缺腿也能跑！ 高速断车轴，刹车常漏油！ 开三轮丰田，奔极乐黄泉！ 凯美瑞，凯美瑞，投胎要排队！ 雅力士，雅力士，包你英年早逝！” 赵本山问小沈阳：“这车钢板有没有１公分厚？” 小沈阳：“没有。” 赵本山：“里面有厕所吗？” 小沈阳：“没有”。 赵本山：“有刹车吗？”’ 小沈阳：“有？还是没有？大叔你说呢？” 赵本山：“你卖车还是我卖车你问我？” 小沈阳：“没有”。 赵本山：“这个可以有。” 小沈阳：“这个真…没有。” 小沈阳:“毕老师,你知道开车最痛苦的是什么吗？” 老毕：“呵呵！是什么”? 小沈阳 : “是开着开着发现刹车没了”. 赵本山:“你快拉倒吧,知道开车最最痛苦的是什么吗?是开着开着急刹车，刹是刹住了，后面跟着一辆凯美瑞”。 小沈阳：“我总结了一下，人选车不能太随便。凯美瑞这车啊就是这样，一脚踩下去，车站住了，这一回就过去了，一脚踩下去，车没站住，这一辈子就过去了]]></content>
  </entry>
  <entry>
    <title><![CDATA[对SQLite3的C_C++接口进行简单的类封装]]></title>
    <url>%2F17464%2F</url>
    <content type="text"><![CDATA[最近指导一个项目，看了一下他们写的软件源码，其中有对数据库的使用。由于上一个项目中我们使用了MySQL，可能因为惯性，这个项目中他们仍然使用了MySQL。根据需求，预测项目中产生的数据量非常小，并且使用环境力求简单，所以我建议他们换成SQLite轻型数据库。 我接触使用SQLite3也有几年时间了，Android上使用的java接口、树莓派上使用的python接口等等，但是好像还没有用过C\C++的接口。这个项目还是采用MFC框架编写，因此正好使用一下SQLite3的C\C++接口，写了一个简单的类封装，给他们做个演示。 由于很简单，所以先直接把封装的类贴出来 123456789101112131415161718192021222324// // SQLite.h file#pragma oncetypedef struct sqlite3 sqlite3;//黑暗魔法typedef int (*SQL_callback)(void* para, int cols, char** results, char** names);typedef int(*SQL_open)(const char *dbfile, sqlite3 **ppDb);typedef int(*SQL_close) (sqlite3*);typedef int(*SQL_exec) (sqlite3*, const char *sqlstring, SQL_callback select_callback, void *, char **errmsg );class CSQLite&#123;private: HINSTANCE hDll; sqlite3 *db; SQL_open sql_open; SQL_close sql_close; SQL_exec sql_exec;public: CSQLite(); ~CSQLite(); int open(const char* dbfile); int query(const char * sqlstring, SQL_callback select_callback =NULL ,void* para=NULL); int close();&#125;; 1234567891011121314151617181920212223242526272829303132333435// SQLite.cpp file#include "stdafx.h"#include "SQLite.h"CSQLite::CSQLite()&#123; hDll = LoadLibrary(_T("sqlite3.dll")); if (hDll == NULL) &#123; MessageBox(NULL, _T("数据库模块加载失败"), _T("数据库错误"), MB_OK); exit(-1); &#125; sql_open = (SQL_open)GetProcAddress(hDll, "sqlite3_open"); sql_close = (SQL_close)GetProcAddress(hDll, "sqlite3_close"); sql_exec = (SQL_exec)GetProcAddress(hDll, "sqlite3_exec");&#125;CSQLite::~CSQLite()&#123;&#125;int CSQLite::open(const char* dbfile)&#123; return sql_open(dbfile, &amp;db);&#125;int CSQLite::query(const char * sqlstring, SQL_callback select_callback, void* para)&#123; return sql_exec(db, sqlstring, select_callback, para, NULL);&#125;int CSQLite::close()&#123; return sql_close(db);&#125; 1234567891011121314151617181920212223242526272829// 使用方式#include "SQLite.h"......SQL_callback addSQLtoItem(void *para, int cols, char** results, char** names)&#123; CTESTDlg *dlg = (CTESTDlg*)para; CString str; str.Format(_T("%d"), count + 1); dlg-&gt;m_lHistory.InsertItem(count, str); str.Format(_T("%.1f"), atof(results[0])); dlg-&gt;m_lHistory.SetItemText(count, 1, str); str.Format(_T("%.1f"), atof(results[1])); dlg-&gt;m_lHistory.SetItemText(count, 2, str); str = results[2]; dlg-&gt;m_lHistory.SetItemText(count, 3, str); count++; return 0;&#125;......char *dbfile = "sql.db";char *sqlstring= "select * from test";CSQLite sql;sql.open(dbfile);sql.query(sqlstring,(SQL_callback)addSQLtoItem, this);sql.close();...... 由于官网没有现成的 .h .lib .dll 三件套，要用的话需要自己去编译，好在官网提供了编译好的 .dll .def 两件套，所以我用显示调用DLL动态库的方式使用SQLite3。 为了方便调用DLL里面的函数，我将SQLite3内的主要函数封装成一个类CSQLite，并简单封装出了三个函数： open(const char*) 打开或建立数据库 query(const char*, SQL_callback select_callback =NULL ,void *para=NULL); 执行sql语句以及处理查询结果 close() 关闭数据库 目前来看，这个类足以满足项目的需求了。 最后来看一下效果吧]]></content>
      <tags>
        <tag>sqlite3</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇]]></title>
    <url>%2F35162%2F</url>
    <content type="text"><![CDATA[纪念博客建站这是我的第一篇博客文章，先来写首诗吧 清平调 云想衣裳花想容， 春风拂槛露华浓。若非群玉山头见， 会向瑶台月下逢。一枝红艳露凝香，云雨巫山枉断肠。 借问汉宫谁得似？ 可怜飞燕倚新妆。名花倾国两相欢，长得君王带笑看。解释春风无限恨，沉香亭北倚阑干。 可是我是一个程序员呀 感谢阅读！]]></content>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好多眼睛]]></title>
    <url>%2F37047%2F</url>
    <content type="text"><![CDATA[一个艺术生美女给我发了一个网址，说里面很有意思，说不管这个网页的话就会出现很多眼睛。为了看看究竟是怎么回事，于是就踏上了揭秘真相之路。 她给我的网址是一个设计师的网站，我打开后发现除了比较难看的设计图（我的主观审美鸭，没救了😂）以外，没什么特别的。等了一会儿，仍然没发生什么。在我去做别的事好长一段时间后，再把网页切回来，果然发现了一些端倪，网页上竟出现了几双眼睛。我想吐槽设计师，你这定时器设计的时间间隔也太长了吧😂。 我想那位美女艺术生可能对这些凌乱出现的眼睛感兴趣，为了让她不再焦急地等待，我就自己写了一个静态网页，一样能出现好多眼睛😂。 当然比较简单啦，就是一个定时器而已： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;好多眼睛&lt;/title&gt; &lt;script type="text/javascript" src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; @font-face &#123; font-family: StMarie; src: url(StMarie-Thin.otf); &#125; * &#123; margin: 0; padding: 0; &#125; body &#123; height: 100%; width: 100%; &#125; .cdiv &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; opacity: 0.95; font-family: 'StMarie'; &#125; &lt;/style&gt;&lt;body bgcolor="#FF9B97"&gt; &lt;div class="cdiv"&gt; &lt;div align="center"&gt; &lt;h1&gt;I GAZING ATYOU&lt;/h1&gt; &lt;img src='loader.gif'&gt; &lt;br&gt; &lt;br&gt; &lt;/div&gt; some text &lt;br&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; $(document).ready(function () &#123; setInterval("addEye()", 2000); &#125;); function addEye() &#123; var x = randomFromTo(0, $(window).width()); x = (x + 100) &gt; $(window).width() ? (x - 100) : x; var y = randomFromTo(0, $(window).height()); y = (y + 100) &gt; $(window).height() ? (y - 100) : y; var img0 = "&lt;img src='loader.gif' height='50' width='50' style='position:absolute; left:" + x + "px; top:" + y + "px;' &gt;" $("body").append(img0); &#125; function randomFromTo(from, to) &#123; return Math.floor(Math.random() * (to - from + 1) + from); &#125;&lt;/script&gt; 这样，每隔2秒就会在随机的位置出现一只眼睛了，效果就是开头的那张图了。]]></content>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在树莓派上使用Gogs搭建Git服务]]></title>
    <url>%2F39090%2F</url>
    <content type="text"><![CDATA[Gogs是一个开箱即用的能够提供网页界面的Git服务，美观简洁，类似GitHub。支持常见的数据库，并且内置SQLite3数据库。官网提供多种版本的gogs 环境需求很简单，只需要安装git就可以 在树莓派上试验安装 在gogs下载树莓派版本，解压后放在任意路径，一般会有这些文件 custom/ &nbsp; 存放配置文件，删除后，会重新安装gogs，重新配置 gogs &nbsp; 主程序，使用 gogs web 开启服务 log/ &nbsp; 默认存放log的地方，可在配置文件中修改 README.md scripts/ &nbsp; 一些写好的脚本模板 data/ &nbsp; sqlite3数据库的存放位置（最好和gogs主程序在一起，在配置文件中修改后可能会导致git库读写失败） LICENSE public/ README_ZH.md templates/ 修改service文件，假设gogs文件夹放到了~/1209lab/ 1234567891011121314151617181920212223242526272829[Unit]Description=GogsAfter=syslog.targetAfter=network.target[Service]# Modify these two values and uncomment them if you have# repos with lots of files and get an HTTP error 500 because# of that####LimitMEMLOCK=infinity#LimitNOFILE=65535Type=simpleUser=piGroup=piWorkingDirectory=/home/pi/1209lab/gogsExecStart=/home/pi/1209lab/gogs/gogs webRestart=alwaysEnvironment=USER=pi HOME=/home/pi# Some distributions may not support these hardening directives. If you cannot start the service due# to an unknown option, comment out the ones not supported by your version of systemd.ProtectSystem=fullPrivateDevices=yesPrivateTmp=yesNoNewPrivileges=true[Install]WantedBy=multi-user.target 放到 /lib/systemd/system 下，用下面的代码设置开机启动 12systemctl enable gogs.servicesystemctl start gogs.service 修改配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950APP_NAME = GogsRUN_USER = piRUN_MODE = prod[database]DB_TYPE = sqlite3HOST = 127.0.0.1:3306NAME = gogsUSER = rootPASSWD = SSL_MODE = disablePATH = data/gogs.db[repository]ROOT = /home/pi/1209lab/gogs-repositories[server]DOMAIN = 192.168.1.100HTTP_PORT = 3000ROOT_URL = http://192.168.1.100:3000/DISABLE_SSH = falseSSH_PORT = 22START_SSH_SERVER = falseOFFLINE_MODE = false[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL = falseDISABLE_REGISTRATION = falseENABLE_CAPTCHA = trueREQUIRE_SIGNIN_VIEW = false[picture]DISABLE_GRAVATAR = falseENABLE_FEDERATED_AVATAR = false[session]PROVIDER = file[log]MODE = fileLEVEL = InfoROOT_PATH = /home/pi/1209lab/gogs-log[security]INSTALL_LOCK = trueSECRET_KEY = ivvPmazKANJYz41 基本可以运行了 issue在pull或push时出现 http 401 Unauthorized 错误，解决办法，在git config文件修改，在url中加上user:password 12[remote &quot;1209lab&quot;] url=http://user:password@192.168.1.100:3000/lpp/vege.git]]></content>
      <tags>
        <tag>git</tag>
        <tag>gogs</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于QT的视频播放器]]></title>
    <url>%2F20003%2F</url>
    <content type="text"><![CDATA[项目的需要播放rtsp视频流，因此选择开源的ffmpeg作为解码开发包，并且要使用QT开发。照例，在开始之前先去GitHub上看一看有没有比较成熟的封装，果然找到了几个比较好用的。经过测试，它们都能解码rtsp视频流，但是画面的显示效果差别比较大，可能是因为不熟悉这些sdk的使用，写的demo太简单，没有加入正确的优化吧。下面依次简单介绍一下： 原生的FFmpeg原作者的文章在这里QT下使用ffmpeg播放视频范例 先看一下使用这个原生方案的效果吧。 播放器中显示的视频都是mkv格式文件经过live555产生rtsp视频流，live555服务器部署在同一个局域网内，不存在网络延迟的情况。 可以看到第一个和第四个视频画面是比较完整的，花屏的频率很低，但是只有第四个是流畅播放的，其他三个都存在人眼可见的卡顿。 QtAV 项目项目地址基于Qt和FFmpeg的跨平台高性能音视频播放框架 使用这个框架编写的demo效果： 可以看到和直接使用原生的FFmpeg效果差不多。但是它对FFmpeg和Qt widget封装的很好，使用很简便。对提高项目开发效率非常有利。 VLC-Qt 项目项目地址Quickly create a fully functional cross-platform media player。使用方法也是非常方便，封装的VlcWidgetVideo类可以方便的显示和控制视频播放。我按照作者给出的例子vlc-qt/examples写的demo的效果如下： 可以看到，这是目前效果最好的，画面基本没有花屏，每个都能流畅播放，也达到了项目需求的效果。 可能是因为该框架是基于vlc封装的吧，vlc是在ffmpeg编解码库的基础上开发的框架，加入了很多自己的模块，有自己的封装与优化，所以才会更能自动选择最佳的解码方式吧。 常用的开源编码解码库FFmpeg项目地址A complete, cross-platform solution to record, convert and stream audio and video. 这个应该算是几乎所有播放器的根基了，音视频的编码解码都要依赖或部分依赖这个框架，应用非常广泛。像是暴风影音、QQ影音、KMPlayer等等都是基于FFmpeg库的。其他一部分基于此开发的播放器或项目可以在这里看到 Projects incorporate from FFmpeg 这个框架的说明文档也很详细，如果要深入学习视频编码解码的话，建议学习这个。 Libav项目地址Libav provides cross-platform tools and libraries to convert, manipulate and stream a wide range of multimedia formats and protocols. Libav是FFmpeg的一个分支吧（程序员也有小情绪的，一言不合就另起炉灶），功能和用法几乎一样。他和FFmpeg的基础都是这几个库 libavcodec provides implementation of a wider range of codecs. libavformat implements streaming protocols, container formats and basic I/O access. libavutil includes hashers, decompressors and miscellaneous utility functions. libavfilter provides a mean to alter decoded Audio and Video through chain of filters. libavdevice provides an abstraction to access capture and playback devices. libswresample implements audio mixing and resampling routines. libswscale implements color conversion and scaling routines. 这几个库应该是两个项目共同维护的吧😂 VLC项目地址VLC Developers Corner VLC是一个强大的社区VideoLAN创作的视频播放器，相信用过这个播放器的人肯定不少，尤其是在Linux平台上。VLC的核心就是libvlc库，这个库也是VideoLAN其他应用软件的基础。 There are some very important dependencies: gettext (NLS) for international support (required), libdvbpsi for MPEG-TS files and streams support, libmad for MP3 audio decoding, libmpeg2 for MPEG1 and MPEG2 video support, FFmpeg or libav (libavcodec, libavformat, libpostproc, libswscale and optionally libavio) for MPEG4 and most other audio and video codecs, and many file formats, liba52 for Dolby (AC3) sound, dvdread and dvdnav for DVD playback, live555 for RTSP stream playback, etc. For audio output, you will need probably alsa-lib (on Linux) and/or libpulse (for PulseAudio). For video output, you will normally need XCB/XVideo and/or OpenGL/GLX. And Qt4 is required to get the GUI support. 从官网的Wiki上看，VLC项目也是用到了FFmpeg作为大部分格式的解码器，同时也有自己的解码器。我觉得VLC的播放效果比FFmpeg要好，应该是因为在FFmpeg的基础上有所优化吧。 目前直接从官网下载的程序安装文件是不带sdk的，需要选择平台后下载压缩包（7z Zip），压缩包里面都带有sdk。也可以直接去归档库下载，里面安装包、压缩包都有。 MPlayer项目地址MPlayer播放器 Linux用户应该不会对mplayer陌生，这是一个优秀的命令行播放器。它号称是这个星球上最强的播放器，没有之一😂但是它不仅仅只是一个命令行播放器，它有非常多的GUI，在Linux、Windows、Mac OS上都有非常漂亮的界面，可以在这里看到官网收集到的一些播放器前端MPlayer Frontends 它同样也用到了FFmpeg MPV项目地址mpv is a fork of mplayer2 and MPlayer. It shares some features with the former projects while introducing many more. 从简介可以看出，mpv player是MPlayer的一个分支，同样是一个命令行播放器。但是MPV的播放窗口更美观，功能更丰富，特别像是个GUI了，可以看一下它的播放界面上面有可以点击的按钮，对于不熟悉用键盘操控的人来说，可以非常方便的用鼠标控制播放。大名鼎鼎的国产Linux发行版-Deepin的播放器Deepin movie就是使用的MPV和FFmpeg在QT5上开发的。还有moonplayer也是基于MPV的，其他采用MPV库的播放器可以在这里看到Applications using mpv。这里面一个有意思的播放器MPV-EASY Player，配置简单，并且非常接近原生的体验。]]></content>
      <tags>
        <tag>QT</tag>
        <tag>ffmpeg</tag>
        <tag>vlc</tag>
        <tag>rtsp</tag>
        <tag>mpalyer</tag>
        <tag>MVP</tag>
        <tag>播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在局域网内搭建代理服务器上网]]></title>
    <url>%2F14373%2F</url>
    <content type="text"><![CDATA[因项目的需要，翻阅了一些网络设置的内容，对路由器的认识又清晰并且深入的一步。由于在生活中很常见，我们一般提到的路由器就是指家庭中供手机、电脑中上网用的那个设备。但是严格来说，家用路由器并不是单纯的路由器，还包含了交换机功能，并且使用了端口复用NAT方式与外部进行数据交换(PAT)。 因项目用到了网络通信，虽然用路由器等设备能够完成项目的需求，但是对网络通信的内部细节和原理概念不是很清楚，抽时间查阅了一些有关的资料，并通过项目的经验总结出来了这一篇文章。 简单介绍一下PAT(port address translation)，我们知道家用路由器中要填写一个WAN口IP才能上网，那么这个WAN口IP就是可路由的共有IP地址。那么什么是公有IP呢，互联网规定了IPv4的地址分为共有地址和私有地址，私有地址就是常见的192.168.1.0、10.1.1.0等等地址段，这些地址通常用来设置局域网内电脑的IP。比如我们设置了路由器的访问地址是192.168.1.1，那么连接这个路由器的电脑IP就可以是192.168.1.100（2-254之间）。这些私有IP是帮助我们建设局域网的，只能在局域网内访问，路由器是不会转发私有IP的数据到互联网的，即不可路由。那剩下的公有IP就可以在路由器之间传递数据。因此，为了能够上互联网，就必须有一个公有IP。你的路由器设置好了WAN口，那么公有IP就有了，当你浏览网页时，你的电脑、笔记本、手机上网都会使用这个IP向服务器请求数据，服务器也会发送数据到这个IP地址，也就是发送给你的路由器。然后你的路由器再把数据发给你的电脑，你就看到网页了。 那么问题来了，当你的电脑、笔记本、手机同时上网时，路由器是怎么知道改把哪个数据包发送给电脑、笔记本、手机呢。这既是PAT的作用了，你的电脑、笔记本、手机上网时，路由器都会使用PAT给每个局域网IP分配一个端口号，然后公有IP用这个端口号去访问服务器，服务器返回的数据中也会包含这个端口号，路由器再根据这个端口号把数据发给对应的子网设备。 几个重要的概念 IP地址：互联网协议地址，每一个联网的电脑都有一个IP。 大家都明白啦，每一个电脑都要有IP才能上网，IP就是电脑的地址，告诉别人按照这个地址访问我 子网掩码：从名字子网可以看出，用来划分小块网络的。将IP地址划分为网络地址和主机地址，同一个网络地址的电脑组成一个局域网 通过将IP地址和子网掩码进行位与运算，判断两个IP运算后的结果是不是相同来判断这两个IP是不是属于同一个子网。如果属于同一个子网，则直接通信；如果不是一个子网，则会把数据发送到网关。例如电脑AM的IP为192.168.1.12，电脑BM的IP为192.168.1.22，电脑CM的IP为192.168.2.32，子网掩码都是255.255.255.0。通过IP与子网掩码位与运算后分别得到 AM:192.168.1.0、BM:192.168.1.0、CM:192.168.2.0，看出AM与BM是相同的，即有相同的网络地址 192.1.1，属于一个局域网，通过主机地址 12、22 区分不同的主机；CM跟他们都是不一样的，那么A和B就可以通过交换机通信啦，甚至一根网线直接连接A和B的网口也能通信；但是C属于另一个子网，用一根网线或者一个交换机是无法实现通信的，要想进行通信就必须借助到网关。 网关：子网之间连接的关口。 连接两个子网的设备。例如上面的例子电脑AM BM CM，AM想要与CM通信就必须经过网关的转接 路由器：决定两个电脑之间的网络路径 互联网是超级大的，电脑与电脑（服务器也是电脑）之间存在着很多网关、路由器，网络通信中如何通过这些设备才能把数据发送给正确的电脑，就需要路由器给出一条网络路径。而且点到点的网络路径就不只一条，路由协议一般会给出最优的路径。 为了防止数据在互联网内的路由器之间无限循环和转发，IP协议规定了数据包的生存时间TTL，TTL一般为64。当经过一个路由器时，路由器会将TTL减一，当TTL减到0的时候路由器就会丢弃这个数据包。即一般来说IP数据包最多能经过64个路由器，如果经过64个路由器后还没找到目的电脑，那么数据就消失了。 DHCP：动态主机配置协议 电脑需要配置好IP、子网掩码、网关才能上网，如果一个局域网中有很多电脑时，一个个手动配置就太麻烦了。DHCP服务就能够自动配置网络参数。如果电脑开启了DHCP（自动获取IP地址），那么电脑会主动向局域网广播请求IP地址，DHCP服务器收到后会返回给其配置参数，然后电脑根据得到的配置参数自动设置IP等。当IP地址租期到期后，电脑会再次向DHCP服务器请求一个IP。 NAT：网络地址转换 IP地址分为公有地址和私有地址。公有地址能够在路由器间路由；私有地址只能在局域网中靠交换机连接，不能被路由。比如说你的IP是192.168.1.111，那么同一个局域网的电脑才能够访问你，其他地方的电脑是找不到你的；而百度的IP地址 14.215.177.38 是公有地址，在任何地方都能访问。 当我们访问百度的时候，IP数据包中就包含了源地址（我们电脑的IP）和目的地址（百度服务器的IP），百度的服务器收到我们的请求后会发送数据给我们的电脑，他会将我们电脑的IP作为目的地址发送IP数据包。当我们电脑的IP是公有地址时，我们能够正常收到返回的数据；当我们的电脑IP是局域网的私有地址时，路由器是找不到我们的，也就是通信失败。 为了能够正常通信，就必须告诉百度服务器一个公有地址，一般要去电信申请，然后填入我们的路由器（或者电脑），比如 220.181.57.77 。我们有了这个IP就可以接入互联网了 如果只有一个公有地址220.181.57.77，那么局域网内其他电脑接入互联网也要用这个IP，为了保证都能上网，一般我们会把220.181.57.77写入路由器的wan口，然后局域网内电脑都接入路由器的lan口 当有电脑访问互联网时，比如访问百度，电脑会在IP数据包中填写源地址为自己的IP:Port,目的地址为百度IP:80，然后发出去，首先经过路由器，路由器的NAT服务会开通一个端口并绑定该电脑，然后将IP数据包中源地址换成路由器的公有地址和新开的端口发送出去，等到百度回复的IP数据包到来后，路由器的NAT服务再根据端口号选择将数据包发给哪个电脑，具体如图： NAT 有三种工作方式：静态转换，一个私有地址唯一对应一个公有地址，不可变，需要一个公有地址池；动态转换，一个私有地址随机分配一个公有地址，用完就会释放，需要一个公有地址池；端口多路复用，即上面讲述的方式，共享一个公有地址，通过端口区分局域网内的电脑，极大节约公有地址，并能隐藏局域网内所有主机 正向代理经常听到代理上网，代理，顾名思义，通过第三方访问服务器，即，你上网时，你的电脑不直接访问网站，而是让别的电脑去访问网站，然后把网站数据再发给你，这样你就通过其他的电脑获得了你想要的数据。这样做的好处是可以隐藏你的电脑，因为网站只知道访问它的电脑的信息，因此网站只知道你设置代理的电脑，而你的电脑没有访问网站，网站时不知道你的。 正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。它代理的是客户端。 一般作为用户，只用到正向代理 反向代理反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。它代理的是服务端。 即，反向代理一般用在网站服务器上，用来分担负载压力，分流流量。对于访问者来说，是不知道服务器有没有代理。 正向代理小实验tinyproxy是一个Linux上的轻量级代理软件，实验选择Linux主机作为代理服务器，Windows主机通过代理上网。 Linux安装tinyproxyLinux上，可以下载源码安装，也可以 apt install tinyproxy。 修改配置文件，屏蔽两行 123456#允许任何地址连接#Allow 127.0.0.1#允许任何端口连接#ConnectPort 443#ConnectPort 563 Windows配置代理在代理设置中填入Linux的IP地址和tinyproxy监听的端口号设置好后，用浏览器打开百度，发现无法连接到代理服务器，说明Windows代理设置生效 启动tinyproxy服务tinyproxy -d 在前台运行tinyproxy服务，再次去浏览百度，发现正常访问 这样就可以通过Linux主机代理上网了，可以隐藏自己的Windows电脑了]]></content>
  </entry>
  <entry>
    <title><![CDATA[在VPS上快速搭建hexo博客系统]]></title>
    <url>%2F8698%2F</url>
    <content type="text"><![CDATA[什么是hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。也就是它会将你所有的文章都生成一个个静态网页，有了这些网页文件，你就可以放到任意的服务器上，使用nginx、apache、iis等服务器软件访问。你不需要再花费时间去配置mysql等数据库的支持，大大减轻你的建站工作。本文将向你展示如何快速的在你的服务器上搭建博客网站。hexo使用的命令非常简单，短短的几个字母就可以把你写的内容转换成一个漂亮的网页，并发布到你的VPS上。 123hexo new name #新建一篇文章hexo g #生成静态网页hexo d #部署到服务器 安装hexo 在工作电脑上安装Git、Node.js，并配置好相应的环境变量（一般正确使用安装包安装的软件，环境变量会自动配置好，不需要再去手动添加） 安装hexo 1npm install -g hexo-cli 该命令将hexo安装到nodejs的全局目录，这样你就可以直接在控制台中使用hexo命令了 使用hexo建站hexo创建网站实际上是建立一个工作目录，后续的操作都在这个目录中进行 123hexo init blogcd blognpm install 新建一个blog文件夹，并在其中生成所需的文件，然后用npm安装需要的js包。初始化完成后，文件目录结构为 123456789.├── _config.yml├── node_modules/├── package.json├── scaffolds/├── source/| ├── _drafts| └── _posts└── themes/ 此时就可以在blog文件夹中生成网页文件了，生成后的网页文件将会保存在public文件夹中。自己写的markdown格式的文章保存在 source/_posts 文件夹下。 1hexo new post name #新建一篇文章 此时在 source/_posts 文件夹下会生成 name.md 的文件，使用文本编辑器在 name.md 中写文章（推荐VSCode、Typora）。 写好后，使用命令生成网页，网页文件保存在public文件夹。 1hexo generate #生成静态网页 简写为 $ hexo g 至此，完整的静态网页文件已经生成了，可以将它们放到你的服务器上去啦。浏览效果大致是这样子的 美化网站原生的hexo主题有点丑，其实hexo有很多漂亮的主题，官网也提供主题库链接，选择你喜欢的主题，下载后放到 themes 文件夹下，然后修改hexo的配置文件 _config.yml 中的 theme: theme_name ，改为你下载的theme的文件夹名。下面以next主题为例说明： 更改主题 下载主题到theme文件夹，并将主题文件夹命名为next 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改blog目录下的 _config.yml 中的 theme: next （注意中间的空格） 更改语言、域名等修改blog目录下的 _config.yml 1234567891011121314151617# Sitetitle: 网站名称subtitle: 网站副标题description: 简短描述，可以包含关键字用于SEOkeywords:author: 作者language: zh-CN #设置中文timezone: Asia/Shanghai #设置时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.你的域名.cnroot: /permalink: :title/ #文章的永久链接样式# Writingpost_asset_folder: true #生成资源文件夹，这样就可以将文章的图片等放到与文章同名的文件夹内了 修改主题配置修改next目录下的 _config.yml 12345678910111213141516171819202122232425# Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer.beian: enable: true #显示网站备案信息 icp: 备案说明# Baidu Analytics IDbaidu_analytics: c43cxxxxxxxxxxxxxxxxxxxxxxxxxxxx #使用百度统计收集网站访问信息# Baidu Webmaster tools verification setting# See: https://ziyuan.baidu.com/sitebaidu_site_verification: Bxxxxxxxx #百度站长# Google Webmaster tools verification setting# See: https://www.google.com/webmastersgoogle_site_verification: RMxxxxxxxxxxxxxxxxxx #google站长# Google Analyticsgoogle_analytics: UA-xxxxxxx #google统计# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true #自动提交网页# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties #代码高亮主题 如果想在网页中继承搜索功能，可以打开next主题提供的hexo-generator-searchdb，首先要安装hexo-generator-searchdb，然后在next配置文件 _config.yml 中修改 1234567891011# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false hexo-generator-searchdb 实际上是将所有的文章都写在一个search.xml数据文件中，搜索时只要在search.xml数据文件中查找就能实现查找全网信息的功能。默认配置足可以满足要求，有特殊需要，可以在hexo的配置文件 _config.yml 中添加属性，例如 12345search: path: search.xml #定义数据文件的名字 field: post #搜索范围 post page all format: html #搜索的文件格式 html raw(markdown原文) excerp more limit: 10000 #最大搜索数量 还有很多其他配置，可以把 _config.yml 文件浏览一遍，基本能搞懂各项参数是做什么的 至此，一个个性化的网站就配置好了，在blog文件夹运行 1hexo g 就生成了个性化的网页 进一步修改主题配色等在next/source/css/_custom文件夹下有custom.styl文件，自定义的样式写在该文件中，例如 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Custom styles.// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;// 修改选中字符的颜色/* webkit, opera, IE9 */::selection &#123; background: #00c4b6; color: #f7f7f7;&#125;/* firefox */::-moz-selection &#123; background: #00c4b6; color: #f7f7f7;&#125;// 修改网站头部颜色.headband &#123; height: 3px; background: #49b1f5;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #49b1f5;&#125;.site-subtitle &#123; margin-top: 10px; font-size: 13px; color: #ffffff;&#125;// 修改按键（button）样式.btn &#123; color: #49b1f5; background: #fff; border: 2px solid #49b1f5;&#125;// 按键（button）点击时样式.btn:hover &#123; border-color: #49b1f5; color: #fff; background: #49b1f5;&#125;// 鼠标移动至文章标题时的效果.posts-expand .post-title-link::before &#123; content: ""; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: #49b1f5; visibility: hidden; -webkit-transform: scaleX(0); -moz-transform: scaleX(0); -ms-transform: scaleX(0); -o-transform: scaleX(0); transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125; 优化写作在blog文件夹生成tags和categories目录，这样就会生成\tags,\categories网页，并且文章的tags等都会集中在tags、categories网页中 12hexo new page tagshexo new page categories 修改 scaffolds 文件夹下的 post.md 添加更多属性，这样新建一篇文章时就会自动带上这些属性，不用自己手动输入了 123title: &#123;&#123; title &#125;&#125;tags:categories: hexo本身不支持markdown的画图功能，但是可以使用插件来完成，官方插件 npm install --save hexo-filter-mermaid-diagrams在 _config.yml 添加配置 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: "7.1.2" # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 在 themes/_partials/footer.swig 中添加 12345678&#123;% if theme.mermaid.enable %&#125; &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; mermaid主题可选dark default forest neutral,参考mermaid 至此，美化的网页已经配置好啦。使用hexo g 生成看看效果吧 利用Git在VPS中设置自动部署如果觉得每次都要手动把public文件夹的内容上传到服务器有点麻烦，可以试试hexo提供的deploy功能。 1hexo d #将网页文件部署到服务器 只用这样一条简单的指令就能将生成的网页文件上传带服务器，省去了好多时间。hexo提供了多种deployer，我选择Git作为我的deployer。下面来介绍如何实现这一功能。（我的本地系统Windows，远程VPS系统Ubuntu） 首先配置VPS 安装Git 为了安全起见，新建一个用户，其权限专门用来git操作而不能login， 12sudo adduser blog #新建一个blog用户sudo usermod blog -s /usr/bin/git-shell #设置用户的登陆脚本为git-shell，这样其只拥有git权限 测试是否配置权限成功，可以用blog用户登陆一下，如果登陆失败并出现 12fatal: Interactive git shell is not enabled.hint: ~/git-shell-commands should exist and have read and execute access. 表示blog用户的权限已经配置好了。 由于 hexo d 部署指令没有密码输入功能，所以要用无密码的证书登陆方式。使用Git自带的证书生成程序 ssh-keygen来创建公匙和私匙。 1ssh-keygen.exe -t rsa -C "hexo_blog" #注意当输入密码(passphrase)时保持空密码 使用默认路径和文件名后，会在 C:\Users\name.ssh (具体路径跟你的本地git配置有关) 文件夹内生成两个文件 ‘id_rsa.pub’ ‘id_rsa’ 。将 id_rsa.pub 的内容复制到VPS上blog家目录的 .ssh/authorized_keys 文件内，如果没有这个文件就创建一下。 “ 注意git默认使用名为 id_rsa 的私匙，其他名字会造成git找不到私匙；当有多个私匙时，用 ssh-add keyname 添加私匙 ” 测试证书是否安装成功，同样用blog用户登陆一下，如果能够无密码进入终端并自动退出来，说明安装正确。 在VPS中使用git建立一个裸仓库 (例如 hexo.git)，然后在其 hooks 文件夹中新建 post-receive 脚本（post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户） 1234git init --bare hexo.gitcd hexo.git/hooksecho "git --work-tree=/home/blog/hexo --git-dir=/home/blog/hexo.git checkout -f" &gt; post-receivechmod +x post-receive 注意，/home/blog/hexo 为我的网页文件目录，/home/blog/hexo.git 是git裸仓库，这两个文件夹（包括子目录）都必须属于blog用户，如果不是，要用 chown blog:blog -R ./hexo ./hexo.git 修改所属用户和组。 上述配置完成后，可以在本地用 git clone 测试一下能不能连接 1git clone blog@域名或IP:/home/blog/hexo.git 注意，blog表示的是blog用户，不是blog文件夹。如果能够下载表明git仓库建立成功。如果没有权限下载，要检查是否blog用户拥有文件所有权。 使用nginx或者apache，将sever的根目录指向 /home/blog/hexo 至此，远程VPS的配置就完成了 然后配置本地hexo将工作转移到本地电脑。由于采用了Git的方式进行部署，所以下载hexo提供的git deployer部署插件。 在blog文件夹安装 hexo-deployer-git 1npm install hexo-deployer-git --save 然后修改blog文件夹下的 _config.yml 文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: blog@域名或IP:/home/blog/hexo.git branch: master 修改完成后就试试hexo的自动部署命令吧。 12hexo g #生成网页hexo d #部署到服务器 至此，自动部署到服务器功能已经实现了 写一篇博文试试吧1hexo new post 我的第一篇 该命令会在 source_posts 文件夹下生成 文件：我的第一篇.md 文件夹：我的第一篇\ 。然后放一张图片到 我的第一篇\ 文件夹下 编辑 我的第一篇.md 文件 123456789101112131415161718---title: 我的第一篇tags:- hello worldcategories:---### 纪念博客建站这是我的第一篇博客文章，先来写首诗吧&gt; #### 清平调&gt; + 云想衣裳花想容， 春风拂槛露华浓。若非群玉山头见， 会向瑶台月下逢。一枝红艳露凝香，云雨巫山枉断肠。&gt; + 借问汉宫谁得似？ 可怜飞燕倚新妆。名花倾国两相欢，长得君王带笑看。解释春风无限恨，沉香亭北倚阑干。可是我是一个程序员呀&#123;% asset_img 程序员.jpeg 程序员%&#125;#### 感谢阅读！ 然后生成并部署 12hexo ghexo d 然后就可以在你的网站上看到啦，大致效果就是下图这样的 小BUG打赏功能的文字会不停的旋转，修改 next/source/css/_common/components/post/post-reward.styl 文件，屏蔽动画即可 1234567/*#QR &gt; div:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VSCode上快速搭建LaTex写作环境]]></title>
    <url>%2F54764%2F</url>
    <content type="text"><![CDATA[作为宇宙第一的IDE，VSCode简直无所不能。那么怎么用它来进行LaTex的写作呢？其实超级简单的，一眼就能看会哒！ 总共分三步（重要的事情要大写加粗） 第1步安装VSCode（这都不会的话，那你就别用电脑了） 第2步安装LaTex系统，用的最多的就是TeX Live和MiKTeX 。选择其中一个下载安装，中间用默认的选项就可以了。（我用的MiKTex，因为体积小一些，没有的包可以在使用过程中自动下载；TeX Live全都会装上，占用5G多空间） 第3步打开VSCode，点击扩展按钮，搜索LaTeX Workshop，然后安装 这样就搭建好了，可以用VS写文章了 那么我们来写一个tex文件试试有没有成功 写个helloworld 1234\documentclass&#123;article&#125;\begin&#123;document&#125;Hello, world!\end&#123;document&#125; 保存为sample.tex文件，然后用VSCode打开等个1-2秒就会出现神奇的事情VSCode多了一个按钮！！！没错，冒出来一个TeX按钮。然后点击里面的build就生成pdf文件啦。 什么，竟然有错误别急，那是因为自带的编译链没有合适的，我们自己写一个编译链打开VSCode的setting,搜索recipes，然后打开Latex-workshop的recipes 也就是在UserSetting文件里面添加一段json配置 1234567891011121314151617181920212223"latex-workshop.latex.recipes": [ &#123; "name": "pdflatex", "tools": [ "pdflatex" ] &#125;, &#123; "name": "latexmk 🔃", "tools": [ "latexmk" ] &#125;, &#123; "name": "pdflatex ➞ bibtex ➞ pdflatex × 2", "tools": [ "pdflatex", "bibtex", "pdflatex", "pdflatex" ] &#125; ] 可以根据需要添加自定义的编译链，我这里只添加了一个最简单的pdflatex，其他两个是自带的。保存配置后，再去sample.tex文件，用刚写的pdflatex编译一下，是不是生成来PDF文件啦。什么不知道怎么编译， 按住Ctrl+Shift+P调出命令面板，搜索latex，选择build with recipe,然后在选择pdflatex就OK啦，就开始编译啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于江湖的诗句]]></title>
    <url>%2F4220%2F</url>
    <content type="text"><![CDATA[天下风云出我辈，一入江湖岁月催。皇图霸业谈笑中，不胜人生一场醉。提剑跨骑挥鬼雨，白骨如山鸟惊飞。尘事如潮人如水，只叹江湖几人回。 夜雨八方战孤城，平明剑气看刀声。侠骨千年寻不见，碧血红叶醉秋风。 十步杀人不留痕，壮志凌云豪情挥。醉卧沙场笑风云，妙手回春烟飞灰。电闪雷鸣可乱舞，花语流星正亦邪。 倚楼听风雨，淡看江湖路。]]></content>
  </entry>
  <entry>
    <title><![CDATA[判断电脑的性别]]></title>
    <url>%2F53570%2F</url>
    <content type="text"><![CDATA[新建一个文本文档（.txt），开头写下 1createobject（"sapi.spvoice"）.speak"你听我的声音是男生还是女生" 写好后，另存为.vbs 文件 。双击即可听到文本内容了。声音可能为女生也可能为男生，这要看系统设置了。另外添加适当的标点可以得到更好地收听效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[十大经典排序算法]]></title>
    <url>%2F59395%2F</url>
    <content type="text"><![CDATA[本文转自 狐狸の小窝 作者：cutefox原文出处： https://www.aliserver.net/?p=549 算法概述算法分类十种常见排序算法可以分为两大类： 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 算法复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 2、选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 2.4 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.3 代码实现1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; 3.4 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 4.3 代码实现123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while (gap &lt; len / 3) &#123; // 动态定义间隔序列 gap = gap * 3 + 1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; &#125; return arr;&#125; 4.4 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 5、归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现12345678910111213141516171819202122232425function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125;else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 5.4 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现1234567891011121314151617181920212223242526272829function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left =typeof left !='number' ? 0 : left, right =typeof right !='number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 7、堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现123456789101112131415161718192021222324252627282930313233343536var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; 8、计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现12345678910111213141516171819function countingSort(arr, maxValue) &#123; var bucket =new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 8.4 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 9.3 代码实现1234567891011121314151617181920212223242526272829303132333435function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125;else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets =new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 9.4 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现123456789101112131415161718192021222324var counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value =null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) !=null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 10.4 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python向百度主动提交链接]]></title>
    <url>%2F40653%2F</url>
    <content type="text"><![CDATA[一般为了让百度能更快更好的收录网站内容，我们都会提交一个网站地图链接，即sitemap.xml，然后就等着百度蜘蛛慢慢爬上来了。但是这个过程是比较慢的，可能好几天才能完成。 为了加快收录过程，我们还可以选择主动提交，可以第一时间让百度建立网页索引，对于新网页或者首发内容非常有帮助。 图上是主动提交的入口，需要自己编写程序提交链接。百度给出来几种语言的例子 curl php Post ruby。 在Windows平台上，我觉得Python才是最方便的，因此参照curl的方式用requests包提交链接文件。 12345import requestsurl='http://data.zz.baidu.com/urls?site=yoursite&amp;token=yourtoken'files=&#123;'file':open('urls.txt','rb')&#125;r=requests.post(url,files=files)print(r.text) urls.txt文件里写入网页的链接，一行一个。 返回 success 就表示提交成功了。]]></content>
      <tags>
        <tag>python</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Valine给hexo加上评论功能]]></title>
    <url>%2F57063%2F</url>
    <content type="text"><![CDATA[上次我们把hexo博客系统搭建好了，以后写文章只要 1234hexo new post namevim namehexo ghexo d 就可以把文章发布到我们的网站上。今天我们来给它加上评论功能。hexo支持的评论系统有很多，next主题下目前能用的就有 Disqus 畅言 Valine Gitment LiveRe来必力 五种评论系统。我采用了Valine,该系统简洁快速，搭建过程也只是简单的几次操作就能完成。而且Valine支持匿名评论，不需要注册登录账号。下面来介绍我的搭建过程。 注册LeanCloud由于Valine使用了LeanCloud作为后台数据库，因此你需要在LeanCloud上创建一个应用作为数据云存储库。LeanCloud的注册很简单，免费的应用完全满足个人博客的需要。并且LeanCloud提供了三个节点服务器，分别是华北、华东、美国。当你的服务器在国外时，为了加快评论读写速度，可以选择美国节点。选择好LeanCloud的服务器节点后，就开始创建应用了，点击 &lt;创建应用&gt; 按钮，在弹出的对话框中选择免费的版本（有需要的话请选择收费版）。完成后你就可以看到一个创建好的应用进入应用的设置界面，进入应用key，可以看到 APP ID 和 APP Key，记录这两个值，一会要写到hexo的配置文件。在设置界面进入安全中心，因为我们博客系统只需要评论数据的存储，所以最好关闭其他的服务，只保留数据存储开启。在Web安全域名中写入你的网站域名，这样可以防止非设置域名的网站向LeanCloud数据库写入数据。至此，Valine需要的云存储数据库就设置好了 配置hexo在next主题文件夹写的 1234567891011121314# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: DBPxxxxxxxxxxxxxxxx-xxxxxxxx # your leancloud application appid appkey: HLxxxxxxxxxxxxxxx # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: "你有什么想说的吗?" # comment box placeholder avatar: wavatar # gravatar style guest_info: nick,mail # custom comment header pageSize: 10 # pagination size visitor: false 配置完成后就重新生成一下网页文件试试吧 ^_^ 效果预览评论区的效果大致是这样的评论数据全都保存在LeanCloud的存储库中]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Valine</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用electron创建跨平台应用]]></title>
    <url>%2F38619%2F</url>
    <content type="text"><![CDATA[进来B/S较于传统的C/S越来越受欢迎，Browser-Server模式只需要用户有一个能上网的浏览器即可，所有业务都是在服务器处理，具有跨平台、开发快的特点。但是也存在性能较低、用户体验较差。 electron可以说兼顾了B/S和C/S的优点，使用nodejs开发或者JavaScript开发，具有很高的开发效率与响应速度；同时交互界面向C/S靠拢，使用本地html、css文件创建出优美的界面，使用效果与客户端没有区别。如果觉得MFC、WPF等创建一个好看的桌面应用程序比较麻烦，那么可以试试electron。好多软件都是基于electron开发的，比如Atom、VSCode、GitHub Desktop、GitKraken、SimpleNote、Skype、Typora等等。 electron本身就是一个Chromium浏览器并包含了Node.js，同样使用HTML，CSS和JavaScript来构建界面和处理事件。electron能够做到和桌面应用程序一样的效果，是因为它提供了丰富的桌面系统API，使用非常方便。如果使用过nodejs，那么electron开发就很容易了，官网的doc也非常详细https://electronjs.org。这里记录一下我的第一个app新建一个electron项目和新建一个nodejs项目是一样的，所以要先安装nodejs。可以用包管理器npm创建，新建一个文件夹，然后执行命令： 1npm init 比如我的项目名称为mqtt，上述命令生成的package.json的内容为： 1234567891011&#123; "name": "mqtt", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; 其中的main字段表明程序的入口是index.js。接下来按照nodejs的方式编写index.js 12345678910111213// index.jsconst &#123; app, BrowserWindow &#125; = require('electron');let mainWindow;app.on("ready", function () &#123; mainWindow = new BrowserWindow(&#123; width: 800, height: 600 &#125;); mainWindow.setTitle("mqtt"); mainWindow.loadURL('http://www.baidu.com'); mainWindow.on('closed', function () &#123; mainWindow = null; console.log("window closed."); &#125;);&#125;); 对象app负责控制程序的生命周期，类BrowserWindow用于创建浏览器窗口。 这就是一个最基本的electron应用了，包含package.json与index.js两个文件。到这里都是nodejs的内容，还没有下载过任何东西，接下来就下载electron。electron也采用npm管理，执行命令： 1npm install --save-dev electron 会在node_modules文件夹中下载很多模块，至此，运行环境已搭建好。要想使程序运行起来，还需要做一件事，将package.json中的scripts段添加start脚本： 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "electron ." &#125;, 然后执行命令： 1npm start 就可以看到程序运行了 接下来开始创建自己的UI，新建一个网页文件index.html， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang="ch"&gt;&lt;head&gt; &lt;title&gt;mqtt&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css"&gt; &lt;style&gt; body &#123; height: 100%; background-color: #333; display: -ms-flexbox; display: flex; color: #fff; text-shadow: 0 .05rem .1rem rgba(0, 0, 0, .5); box-shadow: inset 0 0 5rem rgba(0, 0, 0, .5) &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="text-center"&gt; &lt;div class="mx-auto"&gt; &lt;h1&gt;第一个electron应用&lt;/h1&gt; &lt;p&gt;点击开始，等待接收内容&lt;/p&gt; &lt;button class="btn btn-lg btn-outline-success" onclick="sub()"&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开&amp;nbsp;&amp;nbsp;始&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;form&gt; 接收：&lt;textarea id="content" rows="10" class="form-control"&gt;&lt;/textarea&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; function sub() &#123; console.log("mqtt") var mqtt = require('mqtt') var client = mqtt.connect('mqtt://test.mosquitto.org') client.on('connect', function () &#123; console.log("connect") client.publish('hello-server', 'Hello mqtt') console.log("publish") client.subscribe('hello-client') console.log("subscribe") &#125;) client.on('message', function (topic, message) &#123; // message is Buffer console.log(message.toString()) var old=document.getElementById("content").value; document.getElementById("content").value = old+"\n" + message.toString(); &#125;) &#125;&lt;/script&gt; 效果如图： 功能是使用mqttjs订阅一个topic，并将收到的消息显示在文本栏。 对应的入口文件index.js也要修改，将原来的mainWindow.loadURL(&#39;http://www.baidu.com&#39;);改为mainWindow.loadFile(&#39;index.html&#39;);，即： 123456789101112// index.jsconst &#123; app, BrowserWindow &#125; = require('electron');let mainWindow;app.on("ready", function () &#123; mainWindow = new BrowserWindow(&#123; width: 400, height: 600 &#125;); mainWindow.setTitle("mqtt"); mainWindow.loadFile('index.html'); mainWindow.on('closed', function () &#123; mainWindow = null; console.log("window closed."); &#125;);&#125;); 再次执行npm start就会看到上图的画面，当有topic消息来到时，文本栏会显示消息 应用打包最简单的方式是使用electron-packager打包，先用npm install electron-packager -g下载工具，然后在项目文件夹中执行 1electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 但是在国内可能会很慢。也可以直接下载现成的二进制文件https://github.com/electron/electron/releases，然后将项目文件夹命名为app，放到resources文件夹中。 用这样的方式打包应用会使得文件太多太大，有人将electron进行了精简https://weolar.github.io/miniblink/，可以满足一般的应用。]]></content>
      <tags>
        <tag>electron</tag>
        <tag>mqtt</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用itchat和图灵机器人搭建一个聊天微信号]]></title>
    <url>%2F45450%2F</url>
    <content type="text"><![CDATA[上一篇体会到了itchat微信接口的强大与便捷，便想着做一个自动回复的微信，过程很简单，都是现成的接口，调用一下就可以了 整个调试过程也就半个小时，比较简单，直接上代码 1234567891011121314151617181920212223242526272829303132import itchatfrom itchat.content import *import requestsimport json@itchat.msg_register([TEXT,PICTURE,MAP,CARD,NOTE,SHARING])def text_reply(msg): if msg.type==TEXT: reply='hello' text=dict(text=msg.text) inputText=dict(inputText=text) userInfo=dict(apiKey='xxxxxxxxxxxd474eaxxxxx' ,userId='4xxxxxx') postjson=dict(perception=inputText,userInfo=userInfo) postjson=json.dumps(postjson) r = requests.post("http://openapi.tuling123.com/openapi/api/v2", data=postjson) print(r.text) res=r.json() rescode=res['intent']['code'] if rescode &gt;= 0: reply=res['results'][0]['values']['text'] else : if msg.text.find('吗') &gt; -1: reply=msg.text.split('吗')[0]+'!' else : reply=msg.text+'哟!' msg.user.send('%s' % (reply))itchat.auto_login()itchat.run(True) 具体就是要去图灵机器人注册一个账号，创建一个应用，得到apiKey和userID，然后就可以通过http post接口交换聊天信息了。 itchat注册消息到达函数，把朋友发来的消息交给图灵去处理，然后把图灵返回的消息发送给朋友。 效果如下： 另外，代码中还包含了价值一个亿的AI聊天机器人核心代码 更新 百度智能对话 接入百度在人工智能方面也是领头羊的地位，他的 UNIT智能对话平台 也是非常理想的聊天机器人 官网UNIT搭载业界领先的需求理解、对话控制及底层的自然语言处理、知识挖掘等核心技术让您的产品快速拥有对话交互能力， SDK文档UNIT机器人对话API文档 1234567891011121314151617181920212223def baiduAI(yousay): pass post_dict = dict(version='2.0', log_id='UNITTEST_10000') post_dict['service_id'] = 'S19668' post_dict['skill_id'] = '63755' post_dict['session_id'] = '' request_dict = dict(user_id='1111', query=yousay) post_dict['request'] = request_dict postjson = json.dumps(post_dict) r = requests.post( "https://aip.baidubce.com/rpc/2.0/unit/bot/chat?access_token=&#123;24.4d2xxxxxx.1564144088.282335-16652172&#125;", data=postjson) res = r.json() if res['error_code'] == 0: res_dict = dict( code=0, string=res['result']['response']['action_list'][0]['say']) # 返回权重最高的一句话 else: res_dict = dict(code=1, string='') return res_dict]]></content>
      <tags>
        <tag>itchat</tag>
        <tag>微信</tag>
        <tag>图灵机器人</tag>
        <tag>聊天机器人</tag>
        <tag>百度聊天机器人</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用itchat批量获取微信群成员信息]]></title>
    <url>%2F3658%2F</url>
    <content type="text"><![CDATA[为了方便的获取微信群成员的信息，找到了一个很强大的python项目itchat，它将网页微信的各种操作都封装成了朴有天python类，简单的几行代码就能完成需求。项目主页。在这里记录我的操作过程 操作过程首先安装itchat 1pip install itchat 进入python环境，一步一步输入命令代码 123import itchat#登录网页微信，会弹出一个二维码，扫描一下itchat.auto_login() 成功扫描登陆后，python控制台会显示成功 然后就可以操作微信了 123456#获取所有的群roomslist = itchat.get_chatrooms()#通过群名称找到群 myroom=itchat.search_chatrooms(name=u'大侠群')#查看roomlist内容，找到群A的群号ID，一般为‘@@09if83xxx4c2c3850...’形式#获取群A的成员信息，返回一个包含信息的类mems=itchat.update_chatroom('ID', detailedMember=True) 1234567891011#使用json将mems转换为dictimport jsonmemstr=json.dumps(mems)memdict=json.loads(memstr)#取得dict里的listmemlist=memdict['MemberList']#遍历list，将需要的信息写入txtwith open('F:/A.csv','a',encoding='utf-8') as f: for mlist in memlist: strs=mlist['NickName']+','+mlist['DisplayName']+','+mlist['UserName']+','+str(mlist['Sex'])+','+mlist['City']+'\n' f.write(strs) 生成的txt文件可能会存在乱码的情况，一般用utf-8编码打开txt文件后，再转为ANSI编码保存一下就可以解决。如图 扩展itchat的功能很丰富，可以用来部署个人自动微信号（很多淘宝助手的个人微信号估计就是这么做的），可以用来远程控制物联网终端。 类似的项目也有很多 youfou/wxpy: 优秀的api包装和配套插件，微信机器人/优雅的微信个人号API liuwons/wxBot: 类似的基于Python的微信机器人 zixia/wechaty: 基于Javascript(ES6)的微信个人账号机器人NodeJS框架/库 sjdy521/Mojo-Weixin: 使用Perl语言编写的微信客户端框架，可通过插件提供基于HTTP协议的api接口供其他语言调用 HanSon/vbot: 基于PHP7的微信个人号机器人，通过实现匿名函数可以方便地实现各种自定义的功能]]></content>
      <tags>
        <tag>python</tag>
        <tag>itchat</tag>
        <tag>微信</tag>
        <tag>wechat</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用QT的QML语言生成VLC-QT播放器]]></title>
    <url>%2F2756%2F</url>
    <content type="text"><![CDATA[刚刚接触QT，发现它提供的QML可以像网页CSS一样制作界面，很方便。为了熟悉一下QML技术，参照VLC-QT的demo，使用其QML库编写一个简单的视频播放器。 工程很简单，直接贴代码demo.pro12345678910TEMPLATE = appQT += qml quickCONFIG += c++11SOURCES += main.cppRESOURCES += qml.qrcLIBS += -lVLCQtCore -lVLCQtQml main.cpp1234567891011121314151617181920212223#include &lt;QtCore/QCoreApplication&gt;#include &lt;QtGui/QGuiApplication&gt;#include &lt;QtQuick/QQuickView&gt;#include &lt;VLCQtCore/Common.h&gt;#include &lt;VLCQtQml/QmlVideoPlayer.h&gt;int main(int argc, char *argv[])&#123; QCoreApplication::setApplicationName("VLC-Qt QML Player"); QCoreApplication::setAttribute(Qt::AA_X11InitThreads); QGuiApplication app(argc, argv); VlcCommon::setPluginPath(app.applicationDirPath() + "/plugins"); VlcQmlVideoPlayer::registerPlugin(); QQuickView quickView; quickView.setSource(QUrl(QStringLiteral("qrc:/qml/video.qml"))); quickView.setResizeMode(QQuickView::SizeRootObjectToView); quickView.show(); return app.exec();&#125; qml.qrc12345&lt;RCC&gt; &lt;qresource prefix=&quot;/qml&quot;&gt; &lt;file&gt;video.qml&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; video.qml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import VLCQt 1.0import QtQuick.Layouts 1.0Rectangle &#123; width: 1020 height: 620 color: "yellow" GridLayout&#123; id:vo columns: 2 rows:2 anchors.fill: parent Rectangle &#123; id:r1 color: "green" Layout.fillWidth: true Layout.fillHeight: true VlcVideoPlayer &#123; id: vidwidget1 anchors.fill: parent url: "rtsp://192.168.1.3:8554/xiao.mkv" &#125; &#125; Rectangle &#123; id:r2 color: "green" Layout.fillWidth: true Layout.fillHeight: true VlcVideoPlayer &#123; id: vidwidget2 anchors.fill: parent url: "rtsp://192.168.1.3:8554/2.mkv" &#125; &#125; Rectangle &#123; id:r3 color: "green" Layout.fillWidth: true Layout.fillHeight: true VlcVideoPlayer &#123; id: vidwidget3 anchors.fill: parent url: "rtsp://192.168.1.3:8554/3.mkv" &#125; &#125; Rectangle &#123; id:r4 color: "green" Layout.fillWidth: true Layout.fillHeight: true VlcVideoPlayer &#123; id: vidwidget4 anchors.fill: parent url: "rtsp://192.168.1.3:8554/4.mkv" &#125; &#125; &#125;&#125; 效果 有个大问题，这样编译出来的程序，在QT run情况下能够正常运行。但是直接打开exe文件会提示QT5NetWork.dll找不到程序接入点，好奇怪呀，不知道哪里的原因。]]></content>
      <tags>
        <tag>RTSP</tag>
        <tag>QT</tag>
        <tag>QML</tag>
        <tag>VLC-QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用HTTP协议浏览网页的原理]]></title>
    <url>%2F51398%2F</url>
    <content type="text"><![CDATA[HTTP（Hypertext Transfer Protocol）超文本传输协议，是互联网数据传输的基础，目前广泛使用的是http/1.1版本。HTTP是一种请求-响应式的协议，运行在应用层。应用层是TCP/IP模型中的一个层级，为了更好的理解HTTP协议，我们先来了解一下TCP/IP模型。 TCP/IP模型互联网协议簇（Internet Protocol Suite）也就是TCP/IP协议是目前互联网通信的架构，包括5个层次，由高到低分别是应用层、传输层、网络层、数据链路层、物理层（Application Layer Transport Layer Network Layer Data Link Layer Physical Layer）（参考TCP/IP五层协议）。 从上图中可以看到，每层的功能和使用场景都不同。 应用层是应用程序之间交换数据的层级，可以在同一个主机上，也可以在不同的主机之间，运行在此层的协议最常见的就是HTTP；在此层工作的是应用程序 传输层运行在主机与主机之间，作用是为应用层建立一个通信的通道，TCP、UDP协议就是运行在此层；在此层工作的是4层交换机 网络层负责生成和传输我们平时所说的IP数据报（datagram），网络层奠基了互联网，定义了寻址和路由，即通过IP地址将数据报传给下一个主机或路由器；在此层工作的是3层交换机、路由器 数据链路层是基于MAC地址寻址的，运行在交换机组成的局域网中；在此层工作的是2层交换机 物理层就是网线，集线器，中继器，负责编码、解码并传输电信号的 每一层都会对数据进行包装，数据在这些层上一步步传输就完成了互联网的通信，下图清晰的展示了这一过程 可以看到当使用TCP/IP传输数据时，发送端主机将数据一层一层的打包，然后通过网线等传递出去，接收端主机将获得的数据一层一层解包得到最终应用程序能够理解的数据。 graph TB 应用程序产生数据Msg -->传输层给Msg加上TCP或UDP头形成数据段或数据报 传输层给Msg加上TCP或UDP头形成数据段或数据报 --> 网络层给加上IP头形成数据包 网络层给加上IP头形成数据包-->数据链路层给加数据包上MAC头形成数据帧 数据链路层给加数据包上MAC头形成数据帧-->物理层将数据帧编码为电信号传播出去 物理层将得到的电信号解码为数据帧-->数据链路层将数据帧解包为数据包 数据链路层将数据帧解包为数据包-->网络层将数据包解包为数据段或数据报 网络层将数据包解包为数据段或数据报-->传输层将数据段或数据报解包为Msg 传输层将数据段或数据报解包为Msg-->应用程序读取Msg HTTP协议HTTP与TCP在软件开发和使用中，我们经常听到“使用TCP连接方式”，“使用HTTP连接”等。其中的HTTP与TCP的关系对于初学者来说比较容易混淆。通过了解上面的TCP/IP模型，就更能很好的理清HTTP与TCP的关系了。HTTP与TCP是工作在不同层级的协议，应用层的HTTP定义了一种数据请求方式，数据的传输通道是由传输层的TCP建立的。即是，HTTP协议规定了A主机的浏览器软件与B服务器的软件之间的沟通的数据格式，TCP协议负责在A主机与B服务器之间建立数据传输通道。 graph LR id1[A TCP]--HTTP data-->id2[B TCP] TCP建立连接的过程就是我们所熟知的三次握手，终端连接四次握手 sequenceDiagram Client->>Server: SYN Server->>Client: SYN-ACK Client->>Server: ACK ClientF->>ServerF: FIN ServerF->>ClientF: ACK ServerF->>ClientF: FIN ClientF->>ServerF: ACK 其中，SYN:Synchronize Sequence Numbers ；ACK:acknowledgement。 HTTP数据格式HTTP协议是超文本即网页传输协议，是专门用来访问网站的。与之对比的同在应用层的FTP是文件传输协议，是用来与服务器之间传输文件的。两者都需要TCP为它们建立传输通道。既然HTTP规定了浏览器与网站服务器之间通信的数据格式，那我们就来看一看。HTTP是一种请求-响应式协议（Request–Response），请求信息格式与响应信息格式基本相同，都是由4部分组成，都是以文本（ASCII）的形式发送。 graph TB id1[请求行]---id2[请求信息头] id2[请求信息头]---id3[空白行] id3[空白行]---id4[请求正文] id11[状态行]---id12[响应信息头] id12[响应信息头]---id13[空白行] id13[空白行]---id14[响应正文] （上图中，左边为请求数据格式，右边为响应数据格式） 请求行，包括：请求方式（GET、POST），请求URL，协议版本号。用空格开，结尾加回车换行符&lt;CR&gt;&lt;LF&gt;。例如GET /index.html HTTP/1.0 请求信息头，包含User-Agent、Host等信息，参考HTTP头信息列表，同样每一项结尾以回车换行符&lt;CR&gt;&lt;LF&gt;结束 空白行，只能包含回车换行符&lt;CR&gt;&lt;LF&gt;，没有空格 请求正文，包含用POST方式传递的数据 http请求数据实际就是一段文本，第一行为请求行，第二行与空白行之间是信息头，空白行之后是用户发送的数据。 类似的响应数据 状态行，包含协议版本号，状态码，状态消息，例如 HTTP/1.1 200 OK，以&lt;CR&gt;&lt;LF&gt;结尾 响应消息头，包含Content-Type等，以&lt;CR&gt;&lt;LF&gt;结尾 空白行，只能包含回车换行符&lt;CR&gt;&lt;LF&gt;，没有空格 响应正文，即返回的html网页，可以不必以&lt;CR&gt;&lt;LF&gt;结尾，跟随操作系统可以是&lt;LF&gt;或&lt;CR&gt; 下面通过一个实验看看是不是按照这种方式来传输数据。 首先架设了PHP服务器，并用内置的server服务启动一个网站，index.php为 123456&lt;?phpecho "your input is: ";print_r($_GET);if("admin"==$_GET[key])&#123;echo "admin";&#125;?&gt; 然后在index.php文件夹启动服务 1php -S 0.0.0.0:8000 正常启动后如图 使用浏览器访问网页 然后使用Fiddler工具对8000端口进行监听，准捕获数据。为了直观的显示POST和GET方式的区别，我写了一个网页文件，使用提交表单的方式访问php服务器。 123456789101112&lt;form name="input" action="http://192.168.1.50:8000/index.php" method="POST"&gt;name: &lt;input type="text" name="name"&gt;&lt;br&gt;key: &lt;input type="text" name="key"&gt;&lt;input type="submit" value="POST"&gt;&lt;/form&gt;&lt;form name="input" action="http://192.168.1.50:8000/index.php" method="GET"&gt;name: &lt;input type="text" name="name"&gt;&lt;br&gt;key: &lt;input type="text" name="key"&gt;&lt;input type="submit" value="GET"&gt;&lt;/form&gt; 网页效果 在文本框输入内容后，分别点击两个按钮，Fiddler监听的结果为 POST GET 从Fiddle监听的结果可以看到浏览器发送和接受的数据与HTTP协议描述的一致。 总结总结一下就是，当你输入一个网址回车后，浏览器会在你的电脑和网站服务器之间建立一条TCP通道，然后浏览器根据HTTP协议的规定将你的请求格式化为一段文本，在这条TCP通道上传递给服务器。服务器随之做出响应，也按照HTTP协议的规定返回给浏览器一段文本。如果返回的状态码为200，浏览器就会将服务器返回的文本的空白行之后的内容渲染成网页，这样你就看到了一张张精彩的网页了。 值得注意的是，使用GET方式请求，浏览器会将你的表单信息直接显示在请求行的url里，也就是会显示在浏览器的地址栏，缺乏隐私。POST方式会把表单信息作为请求正本包裹在http数据包中，在浏览器的地址栏式看不到的，起到一定的保密作用。]]></content>
      <tags>
        <tag>http</tag>
        <tag>TCP/IP模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事实是这样的]]></title>
    <url>%2F44978%2F</url>
    <content type="text"><![CDATA[据越南新闻网25日报道，2013年3月20日，在西沙东岛附近捕完鱼准备返回的越南渔船QNg96382（此船于13日在高尖石附近被中国海监262、263驱赶），被中国海军786艇发现并进行追逐驱离，追击30分钟后中方进行警告射击，越南渔船被击中起火后逃离 3月20日，我数枚炮弹在我西沙海域内正常飞行，越南渔船不顾国际法，强行将渔船开到我炮弹前方，阻挡我炮弹正常飞行，造成我方数枚炮弹损毁，所幸没有造成我方人员伤亡，强烈谴责越南渔船此行为！并要求越南方面公开赔礼道歉，并赔偿我方损失！]]></content>
  </entry>
  <entry>
    <title><![CDATA[中国简史]]></title>
    <url>%2F54889%2F</url>
    <content type="text"><![CDATA[中国简史（果然够简）盘古说：我开；女娲说：我补；共工说：我撞； 神农说：我尝； 精卫说：我填； 夸父说：我追； 后羿说：我射； 嫦娥说：没射着！ 黄帝说：我们做什么； 尧说：我让； 舜说：我也让； 禹说：咱爷们怎么办？ 启说：让他们球！ 桀说：好玩； 汤说：造反有理了； 夏亡了…… 纣说：痛快； 武王说：我也反了； 商亡了…… 幽王说：点火； 褒姒说：刺激； 周也亡了…… 干将说：我铸； 专诸说：我舞； 荆柯说：我刺； 赢政一躲：没刺着…… 始皇说：我修； 姜女说：我哭； 陈胜说：有种； 项羽说：我举； 刘邦说：我斩； 秦亡了…… 孔子说：我仁； 孟子说：我义； 老子说：我无为； 庄子说：我逍遥； 韩非子说：把他们全抓了。 张良说：我出谋划策； 韩信说：我统帅三军； 萧何说：我运筹帷幄； 高祖说：老婆，怎么办； 吕后说：全喀嚓了。 文景说：我治； 武帝说：我兴； 光武说：我中兴； 献帝说：我说了不算。 张骞说：我通； 班超说：我也通； 苏武说：通个屁！ 卫青说：我打； 霍去病说：我也打； 李广说：我还打； 昭君嫣然晕笑，遂天下太平。 董卓说：我势大； 吕布说：我人帅； 貂婵说：你们俩谁厉害。 董卓完蛋了。 曹操说：快帮我脱鞋迎老许； 刘备说：快给我牵驴来访诸葛； 孙权说：周郎自有妙计安天下； 周瑜说：加油，烧死老曹； 诸葛说：天下三分，人人有份； 司马昭说：向刘备同志学习；晋开始了。司马迁说：要想成功，不怕被宫； 班固说：我要出书； 司马相如说：一首赋稿费一千； 曹操说：抄家伙我要赋诗； 曹植说：命题作文有何难； 孔明说：我要写道动员令； 陶潜说你们累不累呀。遂卷铺盖回家了。 朱温说：我同花顺； 萧道成说：我一条顺； 陈霸先说：重新洗牌…… 杨广说：去扬州观花； 李渊说：消来公费旅游； 李世民说：魏征，你的意思； 李治说：老婆，你的意思； 武则天说：那还不如我说了算； 薛刚说：反了你了！ 骆宾王说：鹅肥； 王勃说：情深； 李白说：酒美； 王维说：景幽； 孟浩然说：风流； 杜甫说：屋漏； 白居易说：抱想琵琶唱OK； 李商隐：我没话说了。 柴荣说：三武废费有我一份； 赵匡胤说：今年流行黄袍子 寇准说：带上瓶醋谈判去； 李刚说：保家卫国； 徽宗说：没保成； 钦宗说：我想回家； 金兀朱说：没门…… 赵构说：把姓岳的抓了； 岳飞说：我有何罪？ 秦桧说：也许有…… 陆游说：我要死了； 文天祥说：死得好，我为你喝彩！ 完颜说：金大； 耶律说：辽大； 成吉思汗说：大你个球！ 忽必烈说：亚欧大陆我说了算…… 朱元璋说：高筑墙； 建文帝说：孙承祖业； 朱棣说：我找我爹； 严嵩说：清史留字； 崇祯说：袁崇焕，你的良心大大地坏了…… 李自成说：歇会，找个小姐来； 吴三桂说：敢泡我老婆； 皇太极说：三桂是个好同志。 顺治说：爱江山更爱美人； 康熙说：江山好管儿子难教； 雍正说：说我狠，我就狠给你们看； 乾隆说：我爹是谁； 嘉庆说：和坤是我爹留给我的遗产…… 施耐庵说：天罡盖地煞； 罗贯中说：曹刘震河腰； 吴承恩说：全盘西化； 曹雪芹说;读书人的事能算淫么； 蒲松龄说：我是另类我怕谁？ 林则徐说：我销； 洪秀全说：我反； 康有为说：我变； 孙中山说：看我的。 慈禧说：木偶戏你当好演呀； 李连英说：有奴才伺候； 李鸿章说：九亿白银，小意思； 袁世凯说：窃国者为诸候？ 蒋介石说：何以家为 毛泽东说：成立了 邓说：我开放 江说：我代表 某说：我保鲜 未完待续…… 纯属娱乐，请勿当真]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次RTP多播测试]]></title>
    <url>%2F7151%2F</url>
    <content type="text"><![CDATA[1 在本机推流与播放音视频推流的时候，ffmpeg分别绑定本地一个端口A、B，然后把视频和音频都推送到同一个组播端口C 播放时从组播端口C拉取数据，因为RTP协议的Payload可以区分视频数据和音频数据。 123456789101112131415161718192021222324252627# 推流视频.\ffmpeg.exe -re -i demo.h264 -vcodec copy -f rtp rtp://233.5.5.5:23466 # 推流音频.\ffmpeg.exe -re -i demo.mp3 -acodec copy -f rtp rtp://233.5.5.5:23466# SDP文件# all.sdpv=0o=- 0 0 IN IP4 127.0.0.1s=White Butterflyc=IN IP4 233.5.5.5t=0 0a=tool:libavformat 57.56.101m=audio 23466 RTP/AVP 14b=AS:128v=0o=- 0 0 IN IP4 127.0.0.1s=No Namec=IN IP4 233.5.5.5t=0 0a=tool:libavformat 57.56.101m=video 23466 RTP/AVP 96a=rtpmap:96 H264/90000 # 播放.\ffplay.exe -protocol_whitelist file,udp,rtp all.sdp 也可以单独播放视频、音频，只需要将SDP分开写就好。 tips 1· PayloadRTP协议中使用Payload标识数据类型，占用7bits，范围0~127。 其中，0~95有明确的定义，比如PT=14为MPEG-1 or MPEG-2 音频audio；PT=32为MPEG-1 or MPEG-2 视频video；PT=33为MPEG-2 Transport Stream（MP2T）包含音频audio和视频video。 96以后是用户自定义的动态负载，上面方式中，ffmpeg默认将H264数据设为PT=96。 一种数据类型使用一种PT，RTP只能携带一种负载（头结构决定了只有一个PT段），所以，音频和视频裸流要分开发送；MP2T中是ts格式的容器，包含音视频的封装格式。 使用mp2t： 12345#推流 输出格式必须使用muxer封装为container，rtp_mpegts.\ffmpeg.exe -re -i .\demo.mp4 -c copy -f rtp_mpegts rtp://233.5.5.5:7788#播放 可以同时播放声音和画面\ffplay.exe rtp://233.5.5.5:7788 tips 2· url ~ sdp使用RTP协议规定的PT值时，可以直接用url方式播放，如.\ffplay.exe rtp://233.5.5.5:23466或\vlc.exe rtp://233.5.5.5:23466使用自定义动态负载时，如PT=96的h264裸流，必须用Session Description Protocol-SDP文件明确说明负载属性。 PT≥96时使用URL，会播放失败： ffmpeg出现错误： 1Unable to receive RTP payload type 96 without an SDP file describing it VLC出现错误： 12SDP required:A description in SDP format is required to receive the RTP stream. Note that rtp:// URIs cannot work with dynamic RTP payload format (96). 2 在局域网的组播和本机组播一样，在一台电脑上推流，在另一台电脑上就可以观看。 推流电脑： 1234# 推流视频.\ffmpeg.exe -re -i demo.h264 -vcodec copy -f rtp rtp://233.5.5.5:23466 # 推流音频.\ffmpeg.exe -re -i demo.mp3 -acodec copy -f rtp rtp://233.5.5.5:23466 拉流电脑： 12 # 播放.\ffplay.exe -protocol_whitelist file,udp,rtp all.sdp 3 VLC播放失败的问题我在测试过程中发现wireshark可以抓取到rtp包，但是vlc就是不能播放。换成ubuntu系统就可以用VLC播放，很奇怪。 这个问题困扰了好久终于发现原因了。是因为虚拟机网卡导致的。 3.1 解决方案当客户端电脑上安装了 Oracle VM VirtualBox 的网卡 VirtualBox Host-Only Ethernet Adapter ，必须禁用这个适配器才能接收到rtp数据，否则vlc、ffplay等不能正常接收，不能播放。 禁用VirtualBox Host-Only Ethernet Adapter后，VLC就可以正常接收到多播数据了。 如果还不能播放，可能是Windows防火墙阻止了，需要去防火墙添加规则，放行VLC的所有数据。 3.2 还有个问题我所在的局域网网络拓扑如下 用一个路由器组成的192.168.1.0/24的局域网，所有设备都是一个网段。 RTP服务器接有无线网卡和有线网卡，RTP推流两路信号分别到233.2.2.2 和 233.4.4.4 两个地址。 用有线连接的电脑都能接收到多播数据包，并且能够在VLC上播放 但是只用无线WiFi连接的电脑收不到多播数据包，更谈不上播放了。在笔记本上用Wireshark抓不到ip为233.x.x.x的包，暂时不知道什么原因。 4 在本机的单播因为单播的本地端口A、B都推送到本地端口C，当有进程和C端口建立连接后，会阻止其他进程再去链接C端口。因此推流时需要把音视频分别推送到不同的端口，然后播放时在不同的端口拉取数据。 即推送时 ： 视频 本地端口A 推送到 本地端口 C 音频 本地端口B 推送到 本地端口 D 播放时： 视频 本地端口E 拉取 本地端口 C 音频 本地端口F 拉取 本地端口 D 123456789101112131415161718192021222324252627# 推流视频.\ffmpeg.exe -re -i demo.h264 -vcodec copy -f rtp rtp://localhost:23477 # 推流音频.\ffmpeg.exe -re -i demo.mp3 -acodec copy -f rtp rtp://localhost:23488# SDP文件# all.sdpv=0o=- 0 0 IN IP4 127.0.0.1s=White Butterflyc=IN IP4 localhostt=0 0a=tool:libavformat 57.56.101m=audio 23488 RTP/AVP 14b=AS:128v=0o=- 0 0 IN IP4 127.0.0.1s=No Namec=IN IP4 localhostt=0 0a=tool:libavformat 57.56.101m=video 23477 RTP/AVP 96a=rtpmap:96 H264/90000 # 播放.\ffplay.exe -protocol_whitelist file,udp,rtp all.sdp ffmpeg vlcffmpeg的播放效果很好，音视频都能流畅播放。VLC可以流畅播放音频，视频总是卡在某一帧，不能更新数据，不知道为什么。 用Wireshark抓包数据是一直更新的]]></content>
      <tags>
        <tag>RTP</tag>
        <tag>多播</tag>
        <tag>SDP</tag>
        <tag>FFMpeg</tag>
        <tag>VLC</tag>
        <tag>局域网多播</tag>
        <tag>局域网组播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python批量修改文件某行内容]]></title>
    <url>%2F43416%2F</url>
    <content type="text"><![CDATA[Python很强大，用来做一些批处理非常便捷。如今又遇到了一批MD文件需要删除或者替换某行的内容，当然行内有固定的关键字，可以用来定位行。 由于文件都比较小，可以一次都读入内存，因此思路是 先把所有内容读取到list， 然后依次对每行查询关键词并替换掉关键词， 最后把修改后的list覆盖保存到源文件。 本次进行批量处理的代码12345678910111213141516171819202122import osrootpath = 'folder_path'ext='.md'replace='keyword'filelists = os.listdir(rootpath)for filename in filelists: if filename.endswith(ext): filepath = os.path.join(rootpath, filename) print(filepath) newlines = [] f = open(filepath, 'r', encoding='utf8') for line in f.readlines(): if line.find(replace) &gt; -1 : print(line) else: newlines.append(line) f.close() with open(filepath, 'w', encoding='utf8') as f: f.writelines(newlines) print(filepath + ' --OK') 进阶版1对于大文件的话，这种全部读出来的方式就不行了，可能会造成内存溢出。对于大文件可以采用’读取一行(或一定量的数据)、处理一行、保存一行‘的方式，建立临时文件，将处理过的数据保存到临时文件，然后再把临时文件改名为源文件，具体为： 1234567891011121314import osfilepath='file.md'nfilepath='file.md.temp'nf=open(nfilepath, 'w', encoding='utf8')with open(filepath, 'r', encoding='utf8') as f: for line in f: if line=='\n': pass else : nf.write(line)nf.close()os.replace(nfilepath,filepath) 但是这样也有缺点，会临时造成硬盘空间的大量占用，当硬盘写满后就会保存失败 进阶版2对于内存和硬盘空间都有严格要求的应用，就只能用文件指针的偏移来修改文件了，即seek()方法。使用时要小心计算seek到正确的位置，而且替换数据时要注意字节长度，不要覆盖后面的内容。]]></content>
      <tags>
        <tag>python</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[news]]></title>
    <url>%2F57962%2F</url>
    <content type="text"><![CDATA[news❤️news❤️news❤️news❤️news❤️news ❤️news❤️]]></content>
  </entry>
  <entry>
    <title><![CDATA[matlab标记]]></title>
    <url>%2F15342%2F</url>
    <content type="text"><![CDATA[1.曲线线型、颜色和标记点类型plot(X1,Y1,LineSpec, …) 通过字符串LineSpec指定曲线的线型、颜色及数据点的标记类型。 线型 意义 颜色 意义 标记类型 意义 - 实线 r 红色 + 加号 -. 点划线 g 绿色 o 圆圈 — 虚线 b 蓝色 * 星号 : 点线 c 蓝绿色 . 点 m 洋红色 x 交叉符号 y 黄色 square(或s) 方格 k 黑色 diamond(或d) 菱形 w 白色 ^ 向上的三角形 v 向下的三角形 > 向左的三角形 &lt; 向右的三角形 pentagram(或p) 五边形 hexagram(或h) 六边形 2.设置曲线线宽、标记点大小，标记点边框颜色和标记点填充颜色等。plot(…,’Property Name’, Property Value, …) Property Name 意义 选项 LineWidth 线宽 数值，如0.5，1等，单位为points MarkerEdgeColor 标记点边框线条颜色 颜色字符，如’g’, ’b’等 MarkerFaceColor 标记点内部区域填充颜色 颜色字符 MarkerSize 标记点大小 数值，单位为points 3.坐标轴设置范围设置： axis([xmin xmax ymin ymax])设置坐标轴在指定的区间 axis auto 将当前绘图区的坐标轴范围设置为MATLAB自动调整的区间 axis manual 冻结当前坐标轴范围，以后叠加绘图都在当前坐标轴范围内显示 axis tight 采用紧密模式设置当前坐标轴范围，即一用户数据范围为坐标轴范围 比例： axis equal 等比例坐标轴 axis square 以当前坐标轴范围为基础，将坐标轴区域调整为方格形 axis normal 自动调整纵横轴比例，使当前坐标轴范围内的图形显示达到最佳效果 范围选项和比例设置可以联合使用，默认的设置为axis auto normal 4.坐标轴刻度设置set(gca, ’XTick’, [0 1 2]) X坐标轴刻度数据点位置set(gca,’XTickLabel’,{‘a’,’b’,’c’}) X坐标轴刻度处显示的字符set(gca,’FontName’,’Times New Roman’,’FontSize’,14)设置坐标轴刻度字体名称，大小‘FontWeight’,’bold’ 加粗 ‘FontAngle’,’italic’ 斜体对字体的设置也可以用在title, xlabel, ylabel等中 5.图例legend(‘a’,’Location’,’best’) 图例位置放在最佳位置 6.更多的设置可以在绘图窗口中打开绘图工具，Inspector… 中查找]]></content>
  </entry>
  <entry>
    <title><![CDATA[micro_httpd微型Web服务器学习]]></title>
    <url>%2F26395%2F</url>
    <content type="text"><![CDATA[已经建过好多网站了，可是还不太清楚网页服务器的原理，百度发现了一个微型的服务器micro_httpd，然后就进行了一天的探究。代码不长，就一个C文件，300来行。使用了inetd守护进程提供服务，inetd是Linux下的一个超级守护进程，负责管理很多网络相关的服务，它会监听网络请求，然后再将请求交给它管理的对应的服务去处理。所以micro_httpd只能在linux系统中运行。跟随micro_httpd.c的还有一个makefile文件，编译过程很简单，只要make一下就会生成可执行程序。首先把所有代码贴上来： 程序源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;dirent.h&gt;#include &lt;ctype.h&gt;#include &lt;time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define SERVER_NAME "micro_httpd"#define SERVER_URL "http://www.acme.com/software/micro_httpd/"#define PROTOCOL "HTTP/1.0"#define RFC1123FMT "%a, %d %b %Y %H:%M:%S GMT"/* Forwards. */static void file_details(char *dir, char *name);static void send_error(int status, char *title, char *extra_header, char *text);static void send_headers(int status, char *title, char *extra_header, char *mime_type, off_t length, time_t mod);static char *get_mime_type(char *name);static void strdecode(char *to, char *from);static int hexit(char c);static void strencode(char *to, size_t tosize, const char *from);int main(int argc, char **argv)&#123; char line[10000], method[10000], path[10000], protocol[10000], idx[20000], location[20000]; char *file; size_t len; int ich; struct stat sb; FILE *fp; struct dirent **dl; int i, n; if (argc != 2) send_error(500, "Internal Error", (char *)0, "Config error - no dir specified."); if (chdir(argv[1]) &lt; 0) send_error(500, "Internal Error", (char *)0, "Config error - couldn't chdir()."); if (fgets(line, sizeof(line), stdin) == (char *)0) send_error(400, "Bad Request", (char *)0, "No request found."); if (sscanf(line, "%[^ ] %[^ ] %[^ ]", method, path, protocol) != 3) send_error(400, "Bad Request", (char *)0, "Can't parse request."); while (fgets(line, sizeof(line), stdin) != (char *)0) &#123; if (strcmp(line, "\n") == 0 || strcmp(line, "\r\n") == 0) break; &#125; if (strcasecmp(method, "get") != 0) send_error(501, "Not Implemented", (char *)0, "That method is not implemented."); if (path[0] != '/') send_error(400, "Bad Request", (char *)0, "Bad filename."); file = &amp;(path[1]); strdecode(file, file); if (file[0] == '\0') file = "./"; len = strlen(file); if (file[0] == '/' || strcmp(file, "..") == 0 || strncmp(file, "../", 3) == 0 || strstr(file, "/../") != (char *)0 || strcmp(&amp;(file[len - 3]), "/..") == 0) send_error(400, "Bad Request", (char *)0, "Illegal filename."); if (stat(file, &amp;sb) &lt; 0) send_error(404, "Not Found", (char *)0, "File not found."); if (S_ISDIR(sb.st_mode)) &#123; if (file[len - 1] != '/') &#123; (void)snprintf( location, sizeof(location), "Location: %s/", path); send_error(302, "Found", location, "Directories must end with a slash."); &#125; (void)snprintf(idx, sizeof(idx), "%sindex.html", file); if (stat(idx, &amp;sb) &gt;= 0) &#123; file = idx; goto do_file; &#125; send_headers(200, "Ok", (char *)0, "text/html", -1, sb.st_mtime); (void)printf("\&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n\&lt;html&gt;\n\ &lt;head&gt;\n\ &lt;meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\"&gt;\n\ &lt;title&gt;Index of %s&lt;/title&gt;\n\ &lt;/head&gt;\n\ &lt;body bgcolor=\"#99cc99\"&gt;\n\ &lt;h4&gt;Index of %s&lt;/h4&gt;\n\ &lt;pre&gt;\n", file, file); n = scandir(file, &amp;dl, NULL, alphasort); if (n &lt; 0) perror("scandir"); else for (i = 0; i &lt; n; ++i) file_details(file, dl[i]-&gt;d_name); (void)printf("\ &lt;/pre&gt;\n\ &lt;hr&gt;\n\ &lt;address&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/address&gt;\n\ &lt;/body&gt;\n\&lt;/html&gt;\n", SERVER_URL, SERVER_NAME); &#125; else &#123; do_file: fp = fopen(file, "r"); if (fp == (FILE *)0) send_error(403, "Forbidden", (char *)0, "File is protected."); send_headers(200, "Ok", (char *)0, get_mime_type(file), sb.st_size, sb.st_mtime); while ((ich = getc(fp)) != EOF) putchar(ich); &#125; (void)fflush(stdout); exit(0);&#125;static voidfile_details(char *dir, char *name)&#123; static char encoded_name[1000]; static char path[2000]; struct stat sb; char timestr[16]; strencode(encoded_name, sizeof(encoded_name), name); (void)snprintf(path, sizeof(path), "%s/%s", dir, name); if (lstat(path, &amp;sb) &lt; 0) (void)printf("&lt;a href=\"%s\"&gt;%-32.32s&lt;/a&gt; ???\n", encoded_name, name); else &#123; (void)strftime(timestr, sizeof(timestr), "%d%b%Y %H:%M", localtime(&amp;sb.st_mtime)); (void)printf("&lt;a href=\"%s\"&gt;%-32.32s&lt;/a&gt; %15s %14lld\n", encoded_name, name, timestr, (long long)sb.st_size); &#125;&#125;static voidsend_error(int status, char *title, char *extra_header, char *text)&#123; send_headers(status, title, extra_header, "text/html", -1, -1); (void)printf("\&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n\&lt;html&gt;\n\ &lt;head&gt;\n\ &lt;meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\"&gt;\n\ &lt;title&gt;%d %s&lt;/title&gt;\n\ &lt;/head&gt;\n\ &lt;body bgcolor=\"#cc9999\"&gt;\n\ &lt;h4&gt;%d %s&lt;/h4&gt;\n", status, title, status, title); (void)printf("%s\n", text); (void)printf("\ &lt;hr&gt;\n\ &lt;address&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/address&gt;\n\ &lt;/body&gt;\n\&lt;/html&gt;\n", SERVER_URL, SERVER_NAME); (void)fflush(stdout); exit(1);&#125;static voidsend_headers(int status, char *title, char *extra_header, char *mime_type, off_t length, time_t mod)&#123; time_t now; char timebuf[100]; (void)printf("%s %d %s\015\012", PROTOCOL, status, title); (void)printf("Server: %s\015\012", SERVER_NAME); now = time((time_t *)0); (void)strftime(timebuf, sizeof(timebuf), RFC1123FMT, gmtime(&amp;now)); (void)printf("Date: %s\015\012", timebuf); if (extra_header != (char *)0) (void)printf("%s\015\012", extra_header); if (mime_type != (char *)0) (void)printf("Content-Type: %s\015\012", mime_type); if (length &gt;= 0) (void)printf("Content-Length: %lld\015\012", (long long)length); if (mod != (time_t)-1) &#123; (void)strftime(timebuf, sizeof(timebuf), RFC1123FMT, gmtime(&amp;mod)); (void)printf("Last-Modified: %s\015\012", timebuf); &#125; (void)printf("Connection: close\015\012"); (void)printf("\015\012");&#125;static char *get_mime_type(char *name)&#123; char *dot; dot = strrchr(name, '.'); if (dot == (char *)0) return "text/plain; charset=UTF-8"; if (strcmp(dot, ".html") == 0 || strcmp(dot, ".htm") == 0) return "text/html; charset=UTF-8"; if (strcmp(dot, ".xhtml") == 0 || strcmp(dot, ".xht") == 0) return "application/xhtml+xml; charset=UTF-8"; if (strcmp(dot, ".jpg") == 0 || strcmp(dot, ".jpeg") == 0) return "image/jpeg"; if (strcmp(dot, ".gif") == 0) return "image/gif"; if (strcmp(dot, ".png") == 0) return "image/png"; if (strcmp(dot, ".css") == 0) return "text/css"; if (strcmp(dot, ".xml") == 0 || strcmp(dot, ".xsl") == 0) return "text/xml; charset=UTF-8"; if (strcmp(dot, ".au") == 0) return "audio/basic"; if (strcmp(dot, ".wav") == 0) return "audio/wav"; if (strcmp(dot, ".avi") == 0) return "video/x-msvideo"; if (strcmp(dot, ".mov") == 0 || strcmp(dot, ".qt") == 0) return "video/quicktime"; if (strcmp(dot, ".mpeg") == 0 || strcmp(dot, ".mpe") == 0) return "video/mpeg"; if (strcmp(dot, ".vrml") == 0 || strcmp(dot, ".wrl") == 0) return "model/vrml"; if (strcmp(dot, ".midi") == 0 || strcmp(dot, ".mid") == 0) return "audio/midi"; if (strcmp(dot, ".mp3") == 0) return "audio/mpeg"; if (strcmp(dot, ".ogg") == 0) return "application/ogg"; if (strcmp(dot, ".pac") == 0) return "application/x-ns-proxy-autoconfig"; return "text/plain; charset=UTF-8";&#125;static voidstrdecode(char *to, char *from)&#123; for (; *from != '\0'; ++to, ++from) &#123; if (from[0] == '%' &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])) &#123; *to = hexit(from[1]) * 16 + hexit(from[2]); from += 2; &#125; else *to = *from; &#125; *to = '\0';&#125;static inthexit(char c)&#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c - '0'; if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') return c - 'a' + 10; if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') return c - 'A' + 10; return 0; /* shouldn't happen, we're guarded by isxdigit() */&#125;static voidstrencode(char *to, size_t tosize, const char *from)&#123; int tolen; for (tolen = 0; *from != '\0' &amp;&amp; tolen + 4 &lt; tosize; ++from) &#123; if (isalnum(*from) || strchr("/_.-~", *from) != (char *)0) &#123; *to = *from; ++to; ++tolen; &#125; else &#123; (void)sprintf(to, "%%%02x", (int)*from &amp; 0xff); to += 3; tolen += 3; &#125; &#125; *to = '\0';&#125; 从main函数中能够大致知道它的运行流程： 读入一个字符串参数，作为网页文件的根目录root，并切换到该文件夹 从标准输入流读取一段字符line 在line中以空格为分隔符提取三个变量 method path protocl分别是请求方式，请求路径，http版本号 只接受GET请求方式 如果path是路径的话，读取root下的path/index.html文件 如果path是文件，则直接读取该文件 读取文件成功后，先发送信息头HTTP/1.0 200 OK .....，然后发送读取到的文件内容。都是用ASCII字符的形式发送 程序原理解析HTTP协议回顾通过上篇《使用HTTP协议浏览网页的原理》的学习，我们知道，当我们用浏览器浏览网页时，浏览器与网站之间会按照HTTP协议通信。HTTP协议规定了发送的数据都是文本格式（ASCII），并且浏览器发送的请求数据与网站返回的响应数据由格式要求。 对于请求数据来说，第一行字符串为请求行，包含了请求方式（GET/POST）、请求路径和HTTP版本号；第二行到空白行之间的字符串为请求头，包含了User-Agent、Host等信息；空白行之后的字符串为POST方式传递的用户表单数据，GET方式没有数据，这一区域也是空白的。 对于响应数据来说，第一行字符串为状态行，包含了HTTP版本号、状态码和状态消息；第二行与空白行之间是响应消息头，包含了Content-type等属性；空白行之后是网页文本。 请求数据是浏览器负责打包的，而响应数据就是micro_httpd负责包装的了。 micro_httpd解析从上面的micro_httpd源代码中可以再一次验证HTTP协议的规定。浏览器发送的请求数据被micro_httpd从标准输入流stdin读入line(fgets(line, sizeof(line), stdin))，因为第一行为请求行，所以micro_httpd直接从line的开始位置匹配三个用空格隔开的字符串(sscanf(line, &quot;%[^ ] %[^ ] %[^ ]&quot;, method, path, protocol))。这三个字符串按顺序依次是请求方式、请求路径、HTTP版本号。因为只响应GET方式，因此line下面的信息都不用读了，只需要请求地址就可以了。实际应用的网页服务器中，请求头的信息也是有用的，比如可以针对不同的User-Agent提供不同的体验。 有了请求路径URL，micro_httpd会判断这个路径是不是合法的，是不是存在网页root文件夹中，是文件还是目录。错误的URL返回响应的错误send_error。如果一切正确，当URL为目录时，micro_httpd会尝试读取该目录下的index.html((void)snprintf(idx, sizeof(idx), &quot;%sindex.html&quot;, file);)，如果存在index.html则读取其内容，如果不存在则返回状态行和信息头(send_headers(200, &quot;Ok&quot;, (char *)0, &quot;text/html&quot;, -1, sb.st_mtime);)与目录结构； 1234567891011121314151617181920212223(void)printf("\&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;\n\&lt;html&gt;\n\ &lt;head&gt;\n\ &lt;meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\"&gt;\n\ &lt;title&gt;Index of %s&lt;/title&gt;\n\ &lt;/head&gt;\n\ &lt;body bgcolor=\"#99cc99\"&gt;\n\ &lt;h4&gt;Index of %s&lt;/h4&gt;\n\ &lt;pre&gt;\n",file, file);n = scandir(file, &amp;dl, NULL, alphasort);if (n &lt; 0) perror("scandir");else for (i = 0; i &lt; n; ++i) file_details(file, dl[i]-&gt;d_name);(void)printf("\ &lt;/pre&gt;\n\ &lt;hr&gt;\n\ &lt;address&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/address&gt;\n\ &lt;/body&gt;\n\&lt;/html&gt;\n", SERVER_URL, SERVER_NAME); 当URL为文件时，micro_httpd会直接读取该文件返回状态行和信息头(send_headers(200, &quot;Ok&quot;, (char *)0, get_mime_type(file), sb.st_size, sb.st_mtime);)，然后返回文件内容。 12while ((ich = getc(fp)) != EOF) putchar(ich); 从代码中可以看到，返回的数据都是字符串。 实验同样，用浏览器实验一下。首先在micro_httpd服务器的root目录建立index.html文件，内容： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;http原理&lt;/h1&gt; &lt;img src="2.jpg" alt="laptop"&gt; &lt;/body&gt; &lt;/html&gt; micro_httpd服务器地址为192.168.1.50:8080，浏览器访问结果为 我们用Fiddle来看看传输的原始数据，由于网页中存在图片，所以浏览器一共向micro_httpd请求了两次数据，第一次为html文件，第二次为jpg文件 请求index.html文件 请求2.jpg文件 实验结果再一次证实我们对HTTP协议的理解是正确的。 安装micro_httpd正确编译micro_httpd1.进入linux系统下载源代码 2.解压后编译 make 3.得到可执行文件micro_httpd 4.新建一个目录(/home/user/www)，随便写一个index.html，注意可读权限 5.运行程序 micro_httpd /home/user/www，回车 6.然后输入 GET / HTTP/1.0，两次回车 7.出现下面的的结果表示micro_httpd能够正常运行 1234567HTTP/1.0 200 OkServer: micro_httpdDate: Mon, 03 Dec 2018 07:22:50 GMTContent-Type: text/html; charset=UTF-8Content-Length: 1238Last-Modified: Tue, 27 Nov 2018 12:31:52 GMTConnection: close 将micro_httpd加入守护进程micro_httpd自己不会监听端口，需要inetd守护进程监听，然后将请求转发给micro_httpd处理。 在Ubuntu中inetd已经被xinetd替换了。首先要安装xinetd，apt install xinetd，在/etc/xinetd.d中按照例子建立一个配置文件microhttpd（注意等号前后要有空格） 123456789101112# daemon service for micro_httpdservice micro_httpd&#123; socket_type = stream protocol = tcp port = 8080 wait = no user = user server = /home/user/micro_httpd/micro_httpd server_args = /home/user/www/ disable = no&#125; 然后在/etc/services文件中加入micro_httpd的端口号 123# micro_httpdmicro_httpd 8080/tcpmicro_httpd 8080/udp 重新加载xinted服务就可以在浏览器中查看网页了 12sudo systemctl reload xinetd.servicesystemctl status xinetd.service #查看是否有错误 扩展-xinetd守护进程守护进程Daemon根据Archlinux Wiki的描述，daemon是一种后台运行的服务进程，没有人机交互，一直在内存中等待某个事件的发生从而激活服务。最常见的就是网页服务器（web server）。Linux有三种基本的进程：interactive、batch、daemon。区别是 interactive 交互式进程，需要人员输入指令交互 batch 批量进程，后台运行，不需要人机交互，运行完后就推出 daemon 守护进程，后台运行，不需要人机交互，一直停留在内存中 daemon守护进程与Windows系统中的服务（services ）是一样的概念。 xinetdxinetd(extended Internet services daemon)是inetd的扩展版，在很多Linux上已经取代了inetd。根据Wiki的描述，xinetd守护进程是一个超级服务，能管理很多daemons和services，监听多路端口。xinetd通过端口号分发请求，即一个service对应一个端口号。服务与端口号的对应文件为/etc/services，xinetd的配置文件目录/etc/xinetd.conf。xinetd可以在配置instances属性限制同时运行的services数量。 更新另外一个简洁的http服务器Tiny HTTPd增加了POST处理以及CGI处理，代码量也不大，500多行，主要函数： 123456789101112void accept_request(int);void bad_request(int);void cat(int, FILE *);void cannot_execute(int);void error_die(const char *);void execute_cgi(int, const char *, const char *, const char *);int get_line(int, char *, int);void headers(int, const char *);void not_found(int);void serve_file(int, const char *);int startup(u_short *);void unimplemented(int);]]></content>
      <tags>
        <tag>http</tag>
        <tag>daemon</tag>
        <tag>xinetd</tag>
        <tag>micro_httpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bilibili下载器]]></title>
    <url>%2F25221%2F</url>
    <content type="text"><![CDATA[收集到一个非常好用的B站下载器，速度蛮快的。 下载地址：点我下载bilidown.7z]]></content>
      <tags>
        <tag>bilibili</tag>
        <tag>视频解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word排版常用操作]]></title>
    <url>%2F24938%2F</url>
    <content type="text"><![CDATA[问：WORD 里边怎样设置每页不同的页眉？如何使不同的章节显示的页眉不同？答：分节，每节可以设置不同的页眉。文件――页面设置――版式――页眉和页脚――首页不同 问：请问word 中怎样让每一章用不同的页眉？怎么我现在只能用一个页眉，一改就全部改了？答：在插入分隔符里，选插入分节符，可以选连续的那个，然后下一页改页眉前，按一下“同前”钮，再做的改动就不影响前面的了。简言之，分节符使得它们独立了。这个工具栏上的“同前”按钮就显示在工具栏上，不过是图标的形式，把光标移到上面就显示出”同前“两个字来 问：如何合并两个WORD 文档，不同的页眉需要先写两个文件，然后合并，如何做？答：页眉设置中，选择奇偶页不同/与前不同等选项 问：WORD 编辑页眉设置，如何实现奇偶页不同? 比如：单页浙江大学学位论文，这一个容易设；双页：（每章标题），这一个有什么技巧啊？答：插入节分隔符，与前节设置相同去掉，再设置奇偶页不同 问：怎样使WORD 文档只有第一页没有页眉，页脚？答：页面设置－页眉和页脚，选首页不同，然后选中首页页眉中的小箭头，格式－边框和底纹，选择无，这个只要在“视图”――“页眉页脚”，其中的页面设置里，不要整个文档，就可以看到一个“同前”的标志，不选，前后的设置情况就不同了 问：如何从第三页起设置页眉？答：在第二页末插入分节符，在第三页的页眉格式中去掉同前节，如果第一、二页还有页眉，把它设置成正文就可以了 在新建文档中，菜单―视图―页脚―插入页码―页码格式―起始页码为0，确定； 菜单―文件―页面设置―版式―首页不同，确定； 将光标放到第一页末，菜单―文件―页面设置―版式―首页不同―应用于插入点之后，确定。第2 步与第三步差别在于第2 步应用于整篇文档，第3 步应用于插入点之后。这样，做两次首页不同以后，页码从第三页开始从1 编号，完成。 问：WORD 页眉自动出现一根直线，请问怎么处理？答：格式从“页眉”改为“清除格式”，就在“格式”快捷工具栏最左边；选中页眉文字和箭头，格式－边框和底纹－设置选无 问：页眉一般是————-，上面写上题目或者其它，想做的是把这根线变为双线，WORD 中修改页眉的那根线怎么改成双线的?答：按以下步骤操作去做： ●选中页眉的文字，包括最后面的箭头●格式－边框和底纹●选线性为双线的●在预览里，点击左下小方块，预览的图形会出现双线●确定▲上面和下面自己可以设置，点击在预览周围的四个小方块，页眉线就可以在不同的位置 问：Word 中的脚注如何删除？把正文相应的符号删除，内容可以删除，但最后那个格式还在，应该怎么办？答：步骤如下：1、切换到普通视图，菜单中“视图”――“脚注”，这时最下方出现了尾注的编辑栏。2、在尾注的下拉菜单中选择“尾注分隔符”，这时那条短横线出现了，选中它，删除。3、再在下拉菜单中选择“尾注延续分隔符”，这是那条长横线出现了，选中它，删除。4、切换回到页面视图。尾注和脚注应该都是一样的 问：Word 里面有没有自动断词得功能?常常有得单词太长了，如果能设置下自动断词就好了答：在工具―语言―断字―自动断字，勾上，word 还是很强大的 问：如何将word 文档里的繁体字改为简化字？答：工具―语言―中文简繁转换 问：怎样微调WORD 表格线？WORD 表格上下竖线不能对齐，用鼠标拖动其中一条线，可是一拖就跑老远，想微调表格竖线让上下对齐，请问该怎么办答：选定上下两个单元格，然后指定其宽度就可以对齐了，再怎么拉都行press”Alt”，打开绘图，其中有个调整坐标线，单击，将其中水平间距与垂直间距都调到最小值即可。打开绘图，然后在左下脚的绘图网格里设置，把水平和垂直间距设置得最小。 问：怎样微调word 表格线？我的word 表格上下竖线不能对齐，用鼠标拖动其中一条线，可是一拖就跑老远，我想微调表格竖线让上下对齐，请问该怎么办？答：可以如下操作：●按住ctl 键还是shift，你have a try●double click the line, try it :)●打开绘图，设置一下网格（在左下角）。使水平和垂直都为最小，试一把！？●press “Alt” 问：怎么把word 文档里已经有的分页符去掉？答：先在工具――&gt; 选项―― 视图――&gt; 格式标记，选中全部，然后就能够看到分页符，delete 就ok了。 问：Word 中下标的大小可以改的吗?答：格式―字体 问：Word 里怎么自动生成目录啊答：用“格式&gt;&gt;样式和格式”编辑文章中的小标题，然后插入-&gt;索引和目录 问：Word 的文档结构图能否整个复制? 论文要写目录了，不想再照着文档结构图输入一遍，有办法复制粘贴过来吗？答：可以自动生成的，插入索引目录。 问：做目录的时候有什么办法时右边的页码对齐？比如：1.1 标题………………………….11.2 标题………………………….2答：画表格，然后把页码都放到一个格子里靠右或居中，然后让表格的线条消隐就可以了，打印出来就很整齐。 问：怎样在word 中将所有大写字母转为小写？比如一句全大写的转为全小写的答：格式-&gt;更改大小写-&gt;小写 问：在存盘的时候，出现了问题，症状如下：磁盘已满或打开文件过多，不能保存，另开新窗口重存也不管用。如何解决？答：把word 文档全选，然后复制，然后关掉word，电脑提示你粘贴板上有东西，要不要用于别的程序，选是，然后，再重新打开word，然后粘贴，然后，保存。 问：WORD 中的表格一复制粘贴到PPT 中就散掉了，怎么把WORD 里面的表格原样粘贴到PPT 中？答：1）比较好的方法是：先把表格单独存为一WORD 文件，然后插入－－&gt;对象，选由文件创建，然后选中上面的WORD 文件，确定；2）还可以先把表格copy 到excel 中，然后copy 到PPT 中，这个也是比较好的办法；3）可以先做成文本框，再粘贴过去；4）复制粘贴，但是在PPT 中 不能粘在文本框里面；5）拷屏，做成图片，再弄到PPT 里面。 问：有没有办法将PPT 的文字拷入WORD 里面？答：另存就可以了。只要以.rtf 格式另存即可 问：word 中图片的分栏如何处理？假如有：1 2 图3 4 这样的结构，我想实现：1 3 图（要横跨两栏）2 4 但是，试了半天总是：1 2 图3 4 怎么办呀？help！答：设置图片格式――版式――高级――文字环绕――环绕方式选上下型――图片位置――对齐方式选居中――度量依据选页面，要先改文字环绕，然后才能改图片位置 问：用word 写东西时字距老是变动，有时候自动隔得很开，有时候进入下一行的时侯，上一行的字距又自动变大了，这是为什么？怎么纠正啊？答：是因为自动对齐的功能，格式――&gt;段落――&gt;对齐方式可以选。还有允许断字的功能如果check 上，就不会出现你说的情况了。 问：在使用WORD 的样式之后，如标题1、标题2 之类的，在这些样式前面总会出现一个黑黑的方块，虽然打印的时候看不到，但看着总是不舒服，有没有办法让它不要显示呢？答：“视图”－－&gt;“显示段落标志”，把前面的勾去掉。其实这个很有用，可以便于知道哪个是标题段落 问：文章第一页下面要写作者联系方式等。通常格式是一条短划线，下面是联系方式，基金支持等。这样的格式怎么做出来？就是注明页脚吗？答：插入――脚注和尾注 问：文字双栏，而有一张图片特别大，想通栏显示，应该怎么操作？答：可以选择的内容，按双栏排。选择其他内容，按单栏排。 问：Word 里面如何不显示回车换行符？答：把视图-&gt;显示段落标记的勾去掉或工具-&gt;选项-&gt;视图-&gt;段落标记 问：有没有方法把WORD 里的软回车一下子替换掉？识别出来的文字全带着软回车，能把他们一次全删掉吗？？答：查找＋替换，按CTRL+H；软回车好象是^l，在特殊字符里有 问：在WORD 里的框框里怎么打勾？答：画个文本框，文本框里写一个钩，然后拖过去；或者先在WORD 里插入符号“√”，然后选中“√”，到-》格式-》中文版式-》带圈字符-》选“□” 问：还是不行，这样拷过去的框框字体是windings 的，而原来的是宋体的，两者有很大的区别。答：根据模板新建专业型传真，里面有框，双击后打勾，copy 就ok 问：Word 中怎么在一个英文字母上打对号？答：透明方式插入图片对象，内容是一个√ 问：WORD 里怎么显示修订文档的状态？文档修订后，改后标记很多，但是在菜单里没有“显示修订最终状态”等，怎么调出来？答：工具－&gt;自定义－&gt;命令－&gt;类别（工具）－&gt;命令（修订）－&gt;把“修订”等拖到工具栏上 问：怎样把许多分开的word 文档合并成一个文档。我的论文是按照章节分开写的，但现在图书馆要提交电子版的学位论文，是一个文档的，我找了很多选项但好象不能合并，选择插入文件功能，可以加入内容，但文档中的页眉却插不进去，有谁有高见？答：acrobat6 可以直接把多个文档打印成一个pdf 文档。可以提交pdf 格式的论文，先一个一个word 文档转换为pdf 格式的，然后在pdf 文档菜单的文件菜单中，选上作为pdf 格式打开，追加上就可。 问：Word 里面要写方程式怎么办啊？答：插入－对象－公式编辑器equation，如果没有公式编辑器Equation，要自己从光盘中安装，或者安装Mathtype 公式编辑器按右键把它拖出来－－插入－－命令－－自定义－－工具应该是倒过来 问：想在WORD 里面表示矩阵，怎样才能画出那个很大的矩阵括号？答：装公式编辑器mathtype 好了~：） 问：Word 的公式编辑器怎么安装？答：工具－自定义－插入－公式编辑器，把它拖到工具条上即可；或者安装OFFICE 后，再次安装，选增加功能吧，会有提示的 问：Word2000 下调用公式编辑器的快捷键?答：点击菜单[工具]-&gt;[自定义]，点击对话框下方[键盘]，在[类别]里选择[插入]，在命令里选择[InsertEquation]，指定你的快捷方式 问：WORD 中出现公式的行往往要比只有文字的行来得宽，如何把这些行改的跟只有文字的行一样宽？答：段落行距设为固定值即可。这样会有一个问题，比如设置为18 磅，有些公式符号（特别是有下标的）不能全部显示打印稿可以显示。怎么解决这个问题？这个如何解决还需要考虑。 问：我的文档就是公式多，应该怎么办？答：公式多的时候，最好的消除这个问题的办法就是每打几个公式就要存盘，如果连续打太多，就会出现这个问题。出现问题的时候：●选中所有内容，ctrl＋C●把WORD 所有文档关闭， ●最关键：出现一条信息，务必选择“是”●重新打开WORD 编辑器，●ctrl＋V，粘贴●ctrl＋S，存盘 问：怎样在word 里面的公式编辑器中输入空格？答：ctrl+shift+space 问：如何使word 中公式全都小一号？一个一个选实在麻烦答：在Mathtype公式编辑器中：首先，在Mathtype 中的菜单Size 中选define,定义所需的字号大小；再次，在Mathtype 中的菜单preferences 中的equation preference 的save to file 存贮所定义的字号文件；返回word 中：在Mathtype菜单中选Format equation:1）在MathType preference file 中，选你刚才所定义的文件；2）在Range 中，选Whole document。最后，选OK，即OK了。 问：如何将WORD 中的公式编缉拉到外面?答：工具－自定义－命令－插入－右边找公式编辑器，往上脱 问：怎样可以去掉word 里面公式，或是图片上方总是出现的灰色的横条啊？以前没有的，不知道怎么跑出来了，看着怪晕糊的。。。。。答：工具－&gt;选项-&gt;视图-&gt;域底纹，选不显示，或选取时显示，就可以了 问：整个论文用一个WORD 文档，太大，不好编辑，一个地方有增删，后面那么长一个文档版面分布会变得乱七八糟，特别是图表之类的东东。想让每章的偶数页自动显示自己的章号和题目，WORD 里这个能够自动实现吗？答：不要整个论文放一个WORD 文档，一章一个，然后每章就可以奇偶分开处理了 问：论文按照章节写的，想把它们合并成一个文件，并保持原有的文件格式。采用了在文件末尾插入分节符的方法，但插入后有些文件的部分格式发生了变化，请问如何解决？答：用主控文档的方法比较好，在大纲模式里设置的；采取插入文件的方式，格式有些变化 问：WORD 里边怎么样显示行号？答：在页面设置那里，板式选项，最下面有个行号选项 问：Word 里面怎么插入半个空格？答：先在word 的工具栏上，点中双箭头那个纽，就可以看到原先看不到的空格，然后再编辑一下这个空格的大小，比如小五或小四什么的。 问：只要一回车，或是改变光标位置的任何操作，都会使上一行的）变成＝，有人遇到过这个问题么？答：是不是设置了自动替换啊，符号里的自动替换看看吧！ 问：WORD 有没有可以按单词的首字母进行排序？就是从A-Z 进行排答：表格中的内容可以按照拼音排序，弄到excel 里，排序，再回来 问：怎么在word 里面打R^2?答：先打R2，然后用鼠标选中2,同时按”Ctrl”，“shift”和”+” 问：Word 中发现空格都是小圆点，是怎么回事情？每输入一个空格就出现一个小圆点，怎么把它消除掉啊？这个空格会打印出来吗？答：不会打印出来，如果想不显示：工具－选项－视图格式标记中前面的勾去掉即可 问：word 如何使两个表格能排在一起？我做的表格每一个都比较小，但是表格数比较多，我想两个表格排成一行，请问该怎么做？答：试试在局部分栏，每个分栏中一个表格。 问：为什么换机器打开WORD 文档排版变了？在一台机器上排好板的WORD 文档换在另一台机器打开就变了？页码都不对了，怪哉。答：是默认的页面设置不一样吧，或者版本不同 问：Word 里面插入表格的问题，同一表格前后两行被分在了不同的页上，想**他们在同一页怎么做？答：转换成图文框可能更容易排版一点，或者加个文本框 问：怎么在word 里画坐标图?在word 里有了坐标图，文字却加不加去怎么办?答：作图时直接将文字加上去；word 中的绘图工具条，文字环绕里面寻找合适的方案，把图放在文字的底层 问：WORD 文件有密码，怎么办呢？答：找破解软件，比如advanced_office_2000_password_recovery_pro_v1.03，但不一定好用。 问：怎么给word 文档加密？答：打开文档，另存为―工具―常规选项―打开、修改权限密码，保存 问：Word 文件怎么转化为postscript 文件？答：先转化为pdf，然后打印到文件，通过distiller 生成ps。 问：Word 无法识别origin 中的汉字怎么办？用origin 做的图形中有汉字，copy 到word 中就成了问号，因此我不得不先用export 把图形变为jpg 文件才能解决这个问题，有没有方便的解决办法？答：ORIGIN 里面的字体改成宋体或者仿宋 问：请教怎么把Origin 中的图表拷贝到Word？答：点origin 的Edit 菜单里的copy page 到word 里粘贴就行了 问：把origin 的图复制粘贴到word，总有一大块的空白，这个空白有什么工具可以去掉吗？还有就是用word 自带的图表工具画图时，也是有一大块空白去不掉，这个可以解决吗？答：右键选择图片工具栏，点裁减 问：插入的图片为什么老是处于页面的顶端，想拖下来放到其他地方，却又自动跑到顶端去，就是拖不下来，请问该如何处理答：改变图片的属性，就可以了。 问：如何保证一幅图像固定在某一段的后面，另一段的前面，而不会因为前面段落的删减而位置改变？答：右键点击图片－&gt;设置对象格式―&gt;版式―&gt;嵌入型 问：如何把在WORD 里面图形工具画的图转化为jpg？答：另存为html 格式，然后在html 文件对应的文件夹里找 问：请问什么格式的图片插入word 最清晰？手头持有png 和tif 格式，复制粘贴到word 中模糊一片，请问转换成什么图片格式用于word 最清晰？什么方法（插入图片来自文件还是直接复制粘贴）对清晰度有否影响？答：emf，eps 等矢量图最清晰，不会因为缩放损失分辨率，而jpeg，bmp 等点阵图就不行了。 问：在WORD 中如何让图片的左、上、下边都是文本？答：在分栏的数量为1的情况下实现。图片选中后右键，设置图片格式—版式-四周型就可以了 问：jpg 文件插入word 文件以后怎么让文件变小？jpg 格式图片插到word文件以后文件变的巨大，有什么方法可以让它小一点？最好能一张软盘放的下。答：两个方法： ●用photoshop 改变图片的分辨率，当然要看得清楚，然后插入word ●word 有强大的压缩功能，把文档另存为比如：temp.doc，看看是不是小了很多。 问：Matlab 仿真图片大家一般怎么弄到word 里面的?相对横轴和纵轴修改一下的说答：一般都是在Matlab 里面把所有的直接修改好了，然后再保存的时候用jpg 格式，在word 中间导入就好了 问：如何向WORD 中的图片添加文本？想在图片上输入一些说明文字答：插入文本框，将版式设成“悬浮”在WORD 的绘图工具里面有个自选图形，找到你要的括号，直接在页面上画就可以了。可以移动，大小也可以改。然后把他挪到文字边上，即可。一个小窍门就是用CTRL+箭头可以进行微调。如果你 觉得经常需要对这些文字编辑，怕图形错位的话，可以将需要的文字打在一个文本框里，记得将文本框设置成透明无色的（这样就看不见文本框了），然后将文本框和你的括号（或其他符号）组合成一个图形，就万无一失了 问：AUTOCAD 的图拷贝到WORD 下如何处理?答：有几种办法：一是可以在WORD 中进行CAD 编辑的方法：将CAD 的背景设为白色，然后将CAD 窗口缩小，到你想复制的图形的大小，正好可以容纳就可以了，否则WORD 里面有很大的空白，然后，拷贝，选中所有的图形中的线条，右键。到WORD 中粘贴。二是，先转为wmf 文件，具体先将窗口缩小，如上，然后，按emport，选中线条，存储。WORD 中，插入，图形，来自, 文件，找到文件就可以插入了。 问：文章用WORD 打开时，原有的公式全是红叉，以及WORD 中图变成red cross（红叉）怎么办？答：基本上没有办法挽救回来了，只能重新插一遍图。据微软的技术支持所说，红叉是由于资源不够引起的。也就是说，如果你所编辑的文档过大，可能因为资源问题导致图片无法调入，从而显示红叉。可是实际情况是，有时候所编辑的文档并不大，可是还是出现红叉。这就可能是因为你设置了快速保存，在选项菜单中可以找到。这是由WORD 的文档结构所决定的。当你设置为快速保存时，每次保存的时候只是把你改动过的部分添加到文档尾部，并不重写文档本身，以达到快速的目的。所以，你会看到一个本来并不长的文档的实际大小可能有好几兆。当取消了快速保存后，文档长度将大大减小。还有一个减小红叉出现可能性的办法是把图片的属性中的”浮动”去掉。这样可能在编辑的时候有一定的困难，但是对于避免红叉的出现确实很灵。再说一句，一旦红叉出现了，应该是没有办法恢复的，只有再重新贴图。 问：如果Word 突然定在那里了怎么办？答：重新打开会回复，或者在word自身的templates 里面找到近期文件，重写的不用太多。 问：如何解决word 说磁盘已满不让保存的问题？答：有时候，当要保存一个文件时，Word 会弹出一个对话框说是磁盘空间已满，无法保存文件，可实际上磁盘上空间还很大。这是非常令人恼火的一件事情。这一信息最常见的原因是Temp 文件夹已经达到了一个文件夹中可以包含的最多文件数的上限。这时的解决方法很简单：在【资源管理器】中右击安装有Windows 系统的磁盘，在出现的快捷菜单中单击【属性】，将出现【属性】对话框，从【常规】选项卡中选择【磁盘清理】按钮，此时将出现【磁盘清理】对话框。执行磁盘清理完毕以后，Windows 会弹出一个新的对话框。在【要删除的文件】框中选中【临时文件】选项，然后选择【确定】。Windows 将删除临时文件。要人工删除临时文件，进入临时文件夹，删除任何旧的临时文件（临时文件以波浪号开始，以．tmp 扩展名结束），返回Word，再次试着保存文件。如果此时还不能正确保存文档，可以采取以下的方法，步骤如下：（l）按Ctrl＋A 选定整个文档。（2）按Ctrl＋C 将整个文档复制到内存中。（3）关闭Word 程序。此时系统会提示：”您将大量文本放在了’剪贴板’中，是否希望在退出Word 后这些文本仍可用于其他程序？”。（4）选择【是】按钮。（5）重新打开Word 程序。（6）按Ctrl＋V，将复制下来的文本粘贴到新文件中。注意：在删除临时文件时，可能会出现一个对话框，提示不能删除正在使用的文件。这是因为Windows 运行的时候，需要不断地用到一些临时文件。因而，在人工删除临时文件时，试着在开始时只删除几个文件，然后对桌面上的回收站进行清空。否则可能无法删除所有选择的文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lena]]></title>
    <url>%2F2027%2F</url>
    <content type="text"><![CDATA[数字图像处理技巧课上，老师就一张美女图片用了好多次。而且是黑白的，见图挺漂亮的，而且很有玄机，发现没有，。。。。作业PS时又看到了这张图，好奇心起，便google了一下，对比了几张图片，发现这张图背后有个不平凡的故事。 ​ 这是30多年前的故事了。这张图片来源于1972年11月的杂志《PlayBoy》的插页，插页中的人物为瑞典模特Lena Soderberg，而上面这张在数字图像领域广泛使用的图片则是该插页的部分。1973年6月，美国南加州大学的一名教授想找一幅图像来做图像压缩的测试，他已厌倦了手头繁杂的照片，想找张能让人眼前一亮的照片。恰好这时，一人拿着新出的《花花公子》走了进来，Lena的照片确实够让教授眼前一亮了。教授便将《花花公子》的这期插页图用扫描了下来截取其中的一部分作为了他研究使用的样例图像。这位教授就是IPL(图像处理研究所)的 William K. Pratt博士。从此，这幅512X512的经典就诞生了，可以说在图像处理界Lena图像就是学术界的标准。 ​ Lenna图在图像压缩算法是最广泛应用的标准测试图——她的脸部与裸露的肩部已经变成了事实上的工业标准。然而，这张图像的使用也引起了一些争议。一些人担心它的色情内容，觉得图像的来源和严谨的学术研究有些格格不入，认为应该禁止该标准图像；《花花公子》杂志也曾威胁要起诉对Lenna图未经授权的使用。不过这家杂志已经放弃了这种威胁，取而代之的是鼓励因为公众利益使用Lenna图。David C. Munson. （IEEE图像处理期刊主编）在“A Note on Lena” 中给出了两条理由：首先，Lenna图像包含了各种细节、平滑区域、阴影和纹理，这些对测试各种图像处理算法很有用。它是一副很好的测试图像！第二，Lena图像里是一个很迷人的女子。所以不必奇怪图像处理领域里的人（大部分为男性）被一副迷人的图像吸引。 ​ 现在Lena Soderberg 女士居住在她的家乡瑞典，有三个孩子，过着幸福的生活。在1988年的时候，她接受了瑞典一些计算机相关出版社的访问，她对于自己的照片有这样的奇遇感到非常的惊奇与兴奋。这是她第一次知道她的照片被应用在计算机行业。1997年，Lena还被邀请参加了第50届IS&amp;T 会议。 原图 40年后的Lena]]></content>
  </entry>
  <entry>
    <title><![CDATA[MFC编程笔记-debug与release]]></title>
    <url>%2F47989%2F</url>
    <content type="text"><![CDATA[写的一个程序debug版本的release版本运行结果不一致， 深挖原因发现时变量初始化的问题。debug中可以不用初始化，但release下必须初始化，否则就会运行出错。 debug跟release在初始化变量时所做的操作是不同的，debug是将每个字节位都赋成0xcc(注1)，而release的赋值近似于随机(我想是直接从内存中分配的，没有初始化过)。这样就明确了，如果你的程序中的某个变量没被初始化就被引用，就很有可能出现异常：用作控制变量将导致流程导向不一致；用作数组下标将会使程序崩溃；更加可能是造成其他变量的不准确而引起其他的错误。所以在声明变量后马上对其初始化一个默认的值是最简单有效的办法，否则项目大了你找都没地方找。代码存在错误在 debug方式下可能会忽略而不被察觉到，如debug方式下数组越界也大多不会出错，在release中就暴露出来了，这个找起来就比较难了:( 还是自己多加注意吧！ —-引http://www.cnblogs.com/cg_ghost/archive/2012/01/15/2322806.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Matlab和VC++混合编程终极配置版]]></title>
    <url>%2F18226%2F</url>
    <content type="text"><![CDATA[VC6.0版工具-&gt;目录 Win32 Include files 添加：\%$%\Matlab\extern\include Win32 Library files 添加：\%$%\Matlab\extern\lib\win32\microsoft 工程-&gt;设置 C/C++-&gt;Category-&gt;Code Generation-&gt;Use run-time library：Debug Multithread DLL Link-&gt;General-&gt;Object/library modules：添加 mcrmclrrt.lib 和自定义lib,以 空格 隔开 Just Enjoy It！！！ VS2010版（32位）同样适用于VS2005 VS2008 VS2012 属性-&gt;VC++目录-&gt;包含目录 添加：\%$%\Matlab\extern\include 属性-&gt;VC++目录-&gt;库目录 添加：\%$%\Matlab\extern\lib\win32\microsoft 属性-&gt;链接器-&gt;输入-&gt;附加依赖库 添加： mcrmclrrt.lib 和自定义lib,以逗隔开 Just Enjoy It！！！ VS2010版（64位）同样适用于VS2005 VS2008 VS2012 属性-&gt;VC++目录-&gt;包含目录 添加：\%$%\Matlab\extern\include 属性-&gt;VC++目录-&gt;库目录 添加：\%$%\Matlab\extern\lib\win32\microsoft 属性-&gt;链接器-&gt;输入-&gt;附加依赖库 添加： mcrmclrrt.lib 和自定义lib,以 分号 隔开 生成-&gt;配置管理器-&gt;活动的解决方案平台 新建 X64平台 属性-&gt;链接器-&gt;高级-&gt;目标计算机 ：MachineX64 Just Enjoy It！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[PCB各层含义]]></title>
    <url>%2F55620%2F</url>
    <content type="text"><![CDATA[1 Signal layer(信号层)信号层主要用于布置电路板上的导线。Protel 99 SE提供了32个信号层，包括Top layer(顶层)，Bottom layer(底层)和30个MidLayer(中间层)。 2 Internal plane layer(内部电源/接地层) Protel 99 SE提供了16个内部电源层/接地层.该类型的层仅用于多层板，主要用于布置电源线和接地线.我们称双层板，四层板，六层板，一般指信号层和内部电源/接地层的数目。 3 Mechanical layer(机械层)Protel 99 SE提供了16个机械层，它一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。这些信息因设计公司或PCB制造厂家的要求 而有所不同。执行菜单命令Design|Mechanical Layer能为电路板设置更多的机械层。另外，机械层可以附加在其它层上一起输出显示。 4 Solder mask layer(阻焊层)在焊盘以外的各部位涂覆一层涂料，如防焊漆，用于阻止这些部位上锡。阻焊层用于在设计过程中匹配焊盘，是自动产生的。Protel 99 SE提供了Top Solder(顶层)和Bottom Solder(底层)两个阻焊层。 5 Paste mask layer(锡膏防护层，SMD贴片层)它和阻焊层的作用相似，不同的是在机器焊接时对应的表面粘贴式元件的焊盘。Protel 99 SE提供了Top Paste(顶层)和Bottom Paste(底层)两个锡膏防护层。 主要针对PCB板上的SMD元件。如果板全部放置的是Dip(通孔)元件，这一层就不用输出Gerber文件了。在将SMD元件贴PCB板上以前，必须在 每一个SMD焊盘上先涂上锡膏，在涂锡用的钢网就一定需要这个Paste Mask文件,菲林胶片才可以加工出来。 Paste Mask层的Gerber输出最重要的一点要清楚，即这个层主要针对SMD元件，同时将这个层与下面即将介绍的Solder Mask作一比较，弄清两者的不同作用，因为从菲林胶片图中看这两个胶片图很相似。 6 Keep out layer(禁止布线层)用于定义在电路板上能够有效放置元件和布线的区域。在该层绘制一个封闭区域作为布线有效区，在该区域外是不能自动布局和布线的。 7 Silkscreen layer(丝印层)​ 丝印层主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。Protel 99 SE提供了Top Overlay和Bottom Overlay两个丝印层。一般，各种标注字符都在顶层丝印层，底层丝印层可关闭。 8 Multi layer(多层)​ 电路板上焊盘和穿透式过孔要穿透整个电路板，与不同的导电图形层建立电气连接关系，因此系统专门设置了一个抽象的层—多层。一般，焊盘与过孔都要设置在多层上，如果关闭此层，焊盘与过孔就无法显示出来。 9 Drill layer(钻孔层)​ 钻孔层提供电路板制造过程中的钻孔信息(如焊盘，过孔就需要钻孔)。Protel 99 SE提供了Drill gride(钻孔指示图)和Drill drawing(钻孔图)两个钻孔层。 0 相应的在eagle中也有很多的层（常用的用绿色标记）In Layout and Package Editor 1 Top Tracks， top side2 Route2 Inner layer (signal or supply)3 Route3 Inner layer (signal or supply)4 Route4 Inner layer (signal or supply)5 Route5 Inner layer (signal or supply)6 Route6 Inner layer (signal or supply)7 Route7 Inner layer (signal or supply)8 Route8 Inner layer (signal or supply)9 Route9 Inner layer (signal or supply)10 Route10 Inner layer (signal or supply)11 Route11 Inner layer (signal or supply)12 Route12 Inner layer (signal or supply)13 Route13 Inner layer (signal or supply)14 Route14 Inner layer (signal or supply)15 Route15 Inner layer (signal or supply)16 Bottom Tracks， bottom side17 Pads Pads (through-hole)元件的引脚（过孔型，贴片引脚算在顶层和底层上）18 Vias Vias (through all layers)过孔19 Unrouted Airlines (rubber bands)20 Dimension Board outlines (circles for holes) *)板子外形，相当于机械层21 tPlace Silk screen， top side丝印层22 bPlace Silk screen， bottom side丝印层23 tOrigins Origins， top side (generated autom.)元件中间有个十字叉，代表元件位置24 bOrigins Origins， bottom side (generated autom.)25 tNames Service print， top side (component NAME)26 bNames Service print， bottom s. (component NAME)27 tValues Component VALUE， top side28 bValues Component VALUE， bottom side21~28制版时可全部放在丝印层29 tStop Solder stop mask， top side (gen. autom.)30 bStop Solder stop mask， bottom side (gen. Autom.)31 tCream Solder cream， top side32 bCream Solder cream， bottom side33 tFinish Finish， top side34 bFinish Finish， bottom side35 tGlue Glue mask， top side36 bGlue Glue mask， bottom side37 tTest Test and adjustment information， top side38 bTest Test and adjustment inf.， bottom side39 tKeepout Restricted areas for components， top side40 bKeepout Restricted areas for components， bottom s.41 tRestrict Restricted areas for copper， top side42 bRestrict Restricted areas for copper， bottom side43 vRestrict Restricted areas for vias44 Drills Conducting through-holes45 Holes Non-conducting holes46 Milling Milling47 Measures Measures48 Document Documentation49 Reference Reference marks51 tDocu Detailed top screen print52 bDocu Detailed bottom screen print ​ 机械层是定义整个PCB板的外观的，其实我们在说机械层的时候，就是指整个PCB板的外形结构。禁止布线层是我们在布电气特性的铜时定义的边界，也就是说 我们先定义了禁止布线层后，我们在以后的布过程中，所布的具有电气特性的线是不可能超出禁止布线层的边界。topoverlay 和 bottomoverlay 是定义顶层和底层的丝印字符，就是我们在PCB板上看到的元件编号和一些字符。toppaste 和 bottompaste是顶层和底层焊盘层，它就是指我们可以看到的露在外面的铜铂，（比如我们在顶层布线层画了一根导线，这根导线我们在PCB上所看到 的只是一根线而已，它是被整个绿油盖住的，但是我们在这根线的位置上的toppaset层上画一个方形，或一个点，所打出来的板上这个方形和这个点就没有 绿油了，而是铜铂。topsolder 和 bottomsolder 这两个层刚刚和前面两个层相反，可以这样说，这两个层就是要盖绿油的层，multilaye这个层实际上就和机械层差不多了，顾名恩义，这个层就是指 PCB板的所有层。 阻焊层和助焊层的区分​ 阻焊层：solder mask，是指板子上要上绿油的部分；因为它是负片输出，所以实际上有solder mask的部分实际效果并不上绿油，而是镀锡，呈银白色！ ​ 助焊层：paste mask，是机器贴片时要用的，是对应所有贴片元件的焊盘的，大小与toplayer/bottomlayer层一样，是用来开钢网漏锡用的。 ​ 要点：两个层都是上锡焊接用的，并不是指一个上锡，一个上绿油；那么有没有一个层是指上绿油的层，只要某个区域上有该层，就表示这区域是上绝缘绿油的呢？ 暂时我还没遇见有这样一个层！我们画的PCB板，上面的焊盘默认情况下都有solder层，所以制作成的PCB板上焊盘部分是上了银白色的焊锡的，没有上 绿油这不奇怪；但是我们画的PCB板上走线部分，仅仅只有toplayer或者bottomlayer层，并没有solder层，但制成的PCB板上走线 部分都上了一层绿油。 ​ 那可以这样理解：1、阻焊层的意思是在整片阻焊的绿油上开窗，目的是允许焊接！2、默认情况下，没有阻焊层的区域都要上绿油！3、paste mask层用于贴片封装！SMT封装用到了：toplayer层，topsolder层，toppaste层，且toplayer和toppaste一样 大小，topsolder比它们大一圈。 DIP封装仅用到了：topsolder和multilayer层（经过一番分解，我发现multilayer层其实就是 toplayer，bottomlayer，topsolder，bottomsolder层大小重叠），且topsolder/bottomlayer 比toplayer/bottomlayer大一圈。 疑问：“solder层相对应的铜皮层有铜才会镀锡或镀金”这句话是否正确？这句话是一个工作在生产PCB厂的人说的，他的意思就是说：要想使画在 solder层的部分制作出来的效果是镀锡，那么对应的solder层部分要有铜皮（即：与solder层对应的区域要有toplayer或 bottomlayer层的部分）！虽然这么说，但我曾经看到过一块PCB 板，上面一块镀锡区域，只画了solder层，在pcb图上，与它对应的区域并没有铜皮层！不知孰对孰错？ 现在：我得出一个结论：：“solder层相对应的铜皮层有铜才会镀锡或镀金”这句话是正确的！solder层表示的是不覆盖绿油的区域！ PCB的各层定义及描述： 1、TOP LAYER（顶层布线层）：设计为顶层铜箔走线。如为单面板则没有该层。 2、BOMTTOM LAYER（底层布线层）：设计为底层铜箔走线。 3、TOP/BOTTOM SOLDER（顶层/底层阻焊绿油层）：顶层/底层敷设阻焊绿油，以防止铜箔上锡，保持绝缘。在焊盘、过孔及本层非电气走线处阻焊绿油开窗。 ​ 焊盘在设计中默认会开窗（OVERRIDE：0.1016mm），即焊盘露铜箔，外扩0.1016mm，波峰焊时会上锡。建议不做设计变动，以保证可焊性； ​ 过孔在设计中默认会开窗（OVERRIDE：0.1016mm），即过孔露铜箔，外扩0.1016mm，波峰焊时会上锡。如果设计为防止过孔上锡，不要露 铜，则必须将过孔的附加属性SOLDER MASK（阻焊开窗）中的PENTING选项打勾选中，则关闭过孔开窗。 ​ 另外本层也可单独进行非电气走线，则阻焊绿油相应开窗。如果是在铜箔走线上面，则用于增强走线过电流能力，焊接时加锡处理；如果是在非铜箔走线上面，一般设计用于做标识和特殊字符丝印，可省掉制作字符丝印层。 4、TOP/BOTTOM PASTE（顶层/底层锡膏层）：该层一般用于贴片元件的SMT回流焊过程时上锡膏，和印制板厂家制板没有关系，导出GERBER时可删除，PCB设计时保持默认即可。 5、TOP/BOTTOM OVERLAY（顶层/底层丝印层）：设计为各种丝印标识，如元件位号、字符、商标等。 6、MECHANICAL LAYERS（机械层）：设计为PCB机械外形，默认LAYER1为外形层。其它LAYER2/3/4等可作为机械尺寸标注或者特殊用途，如某些板子需要制作导电碳油时可以使用LAYER2/3/4等，但是必须在同层标识清楚该层的用途。 7、KEEPOUT LAYER（禁止布线层）：设计为禁止布线层，很多设计师也使用做PCB机械外形，如果PCB上同时有KEEPOUT和MECHANICAL LAYER1，则主要看这两层的外形完整度，一般以MECHANICAL LAYER1为准。建议设计时尽量使用MECHANICAL LAYER1作为外形层，如果使用KEEPOUT LAYER作为外形，则不要再使用MECHANICAL LAYER1，避免混淆！ 8、MIDLAYERS（中间信号层）：多用于多层板，我司设计很少使用。也可作为特殊用途层，但是必须在同层标识清楚该层的用途。 9、INTERNAL PLANES（内电层）：用于多层板，我司设计没有使用。 10、MULTI LAYER（通孔层）：通孔焊盘层。 11、DRILL GUIDE（钻孔定位层）：焊盘及过孔的钻孔的中心定位坐标层。 12、DRILL DRAWING（钻孔描述层）：焊盘及过孔的钻孔孔径尺寸描述层。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SEO优化-关于img的alt与title]]></title>
    <url>%2F29493%2F</url>
    <content type="text"><![CDATA[SEO(search engine optimization)搜索引擎优化，即使让百度、谷歌等搜索网站能够更容易搜索到你，将你的网站放到一个比较靠前的位置，从而容易得到流量。 关于如何优化SEO的文章已经很多了，我这里主要针对hexo博客系统中的图片标签的优化进行研究。 图片标签是如何影响SEO的在html中图片一般有两个常用的标签 &lt;alt&gt; ， &lt;title&gt; 。例如： 1&lt;img src="dog.png" alt="可爱的小狗" title="狗狗"&gt; 通过查阅网上的解释， &lt;alt&gt; 标签的最初意义在于描述图片的内容，这样在图片无法显示的时候，读者也能大概知道图片是什么样的，同时也照顾了眼睛残疾人士听网页的需求。而 &lt;title&gt; 标签就是给图片起个名字，当鼠标移动到图片上时会出现 &lt;title&gt; 的值。效果如图： &lt;alt&gt; 的值在图片无法显示的时候就会填充在图片区域。 根据Google的说明， &lt;alt&gt; 会在实际上影响SEO，而 &lt;title&gt; 没有作用。具体可以查看google的官方说明Google 图片发布指南。我在其中摘录了一段 效果欠佳（缺少替代文字）：&lt;img src=&quot;puppy.jpg&quot; alt=&quot;&quot;/&gt; 效果欠佳（关键字堆砌）：&lt;img src=&quot;puppy.jpg&quot; alt=&quot;puppy dog baby dog pup pups puppies doggies pups litter puppies dog retriever labrador wolfhound setter pointer puppy jack russell terrier puppies dog food cheap dogfood puppy food&quot;/&gt; 效果较好：&lt;img src=&quot;puppy.jpg&quot; alt=&quot;puppy&quot;/&gt; 效果最佳：&lt;img src=&quot;puppy.jpg&quot; alt=&quot;Dalmatian puppy playing fetch&quot;/&gt; 从这段说明中，我们可以看出，关键词中实际起作用的是 &lt;alt&gt; 标签的值。明白了关键词在哪里写，接下来就改造我们的hexo吧。 优化Hexo在hexo中添加图片的方式常用的有两种，分别是： 121. ![可爱的小狗](dog.png)2. &#123;% asset_img dog.png 可爱的小狗 %&#125; 第1中方式其实是markdown的写法，但是由于hexo的原因，用这种方式生成的网页，图片在主页上能够显示，但是在文章中却不能显示（真是个奇葩的设定，经过观察就是在路径上差了一个反斜杠\）。而第2种方式生成的网页可以完美显示了，但是 &lt;alt&gt; 标签却没有了，换成了 &lt;title&gt; （也是够奇葩的，为什么当初设计程序的时候不把两个标签都写上）。所以为了能够优化SEO，必须把&lt;alt&gt; 加上。好在有人写了一个插件，可以解决markdown方式的路径问题，不用自己再去改代码啦。插件地址 github/hexo-asset-image。使用方式很简单，安装上这个插件后，就可以用markdown的方式连接图片啦。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin系统下笔记本触摸板失灵的问题]]></title>
    <url>%2F14977%2F</url>
    <content type="text"><![CDATA[转到Linux下做一些项目，在笔记本上安装了国产的Deepin linux系统。该系统很漂亮，但是使用过程中发现触摸板工作不正常，经常失灵不工作。查找了一些解决方案，目前算是解决了。根据深度wiki的描述，一般是因为老版本内核没有最新硬件的驱动，所以需要更换一下最新的内核就可以。不同的Linux发行版使用的内核没什么大区别，因此Deepin Ubuntu Debian可以使用一样的内核。我们从(Ubuntu的内核库)[https://kernel.ubuntu.com/~kernel-ppa/mainline/]下载编译好的最新的内核，安装即可。 下载的时候注意区分不同的处理器架构，一般电脑都是64位系统了，所以要下载z这四个包 12345Build for amd64 succeeded (see BUILD.LOG.amd64): linux-headers-5.x_all.deb linux-headers-generic_5.x_amd64.deb linux-image-generic_5.x_amd64.deb linux-modules-generic_5.x_amd64.deb 安装方式： 可以直接双击deb包，调用gui的软件包管理器安装 用 sudo dpkg -i xxxx.deb 安装如果安装有依赖问题，就先安装其他的包。 再启动的时候选择最新的内核就可以了。新内核没有问题就可以卸载老内核了。 卸载方式：依次卸载相应的四个包使用命令 sudo apt remove linux-xxxxxxx Tips在内核仓库中可以看到有两种内核，一种generic,一种lowlatency。根据深度wiki的描述，lowlatency会降低性能。但是这个解释不够具体。 根据Ubuntu的解释：If you do not require low latency for your system then please use the -generic kernel.If you need a low latency system (e.g. for recording audio) then please use the -preempt kernel as a fist choice. This reduces latency but doesn’t sacrifice power saving features. It is available only for 64 bit systems (also called amd64).If the -preempt kernel does not provide enough low latency for your needs (or you have an 32 bit system) then you should try the -lowlatency kernel.If the -lowlatency kernel isn’t enough then you should try the -rt kernelIf the -rt kernel isn’t enough stable for you then you should try the -realtime kernel 大致就是说，lowlatency是一种类似软实时系统，在进程间切换的速度是实时的，低延时的。实时操作系统的缺点就是系统吞吐量减小，适合特定的应用场合。对于普通用户的桌面操作系统来说，generic是最好的。 更新我的神舟似乎用了新内核还是不能正常驱动触摸板，可能Elantech的板子比较独特吧。 用xinput查看(安装方法 apt install xinput) 123456789⎡ Virtual core pointer id=2 [master pointer (3)]⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]⎜ ↳ Logitech G100s Optical Gaming Mouse id=9 [slave pointer (2)]⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=10 [slave keyboard (3)] 根本就没有发现触摸板硬件。难怪不能用呢。 不过，目前有一种解决方案，就是 先进入Windows系统，然后重启进入Linux系统，这样触摸板就能用了，而且功能和Windows下一样哟。 再用xinput查看 12345678910⎡ Virtual core pointer id=2 [master pointer (3)]⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]⎜ ↳ ETPS/2 Elantech Touchpad id=11 [slave pointer (2)]⎜ ↳ Logitech G100s Optical Gaming Mouse id=9 [slave pointer (2)]⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=10 [slave keyboard (3)] Elantech Touchpad有了。 我判断是Elantech的触摸板配置信息直接写入了硬件里面，所以才会在Windows下和Linux下有一样的功能。 好软件推荐跨平台局域网文件互传神器 Dukto有windows、Linux、Mac、Android版本，只要在一个局域网，就可以任意互传。作者网站https://www.msec.it/blog/dukto/]]></content>
      <tags>
        <tag>deepin</tag>
        <tag>linux</tag>
        <tag>驱动</tag>
        <tag>触摸板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo与Hugo-静态博客框架选择]]></title>
    <url>%2F32376%2F</url>
    <content type="text"><![CDATA[使用Hexo有段时间了，总体的感觉还是很方便的，配合宇宙第一IDE：Visual Studio Code，书写、命令、版本管理，一起搞定，都不需要打开文件夹、powershell等。而且主题也很多，各个功能模块也很齐全。唯一的缺点是使用hexo g生成网页的时间有点长，要是还有缺点，那就是项目文件太庞大，因为hexo依赖nodejs，所以工程中需要一大堆node模块，一个工程建下来，差不多有10000个文件了。为了弥补这些缺点，Hugo横空出世了。 Hugo简介​ Hugo号称是世界上最快的静态网页生成器。Hugo是用go语言编写的，go的编译速度非常快，而且运行速度也是杠杠的，据说能和C一教高下。Hugo也提供了多版本的程序供下载，我使用的是win64版本，下载完解压后就是一个exe文件。建立工程也很简单，hugo new site blog就建立了一个博客工程。与其说是一个工程，还不如说是一个目录结构，因为blog目录里面只有6个空文件夹和一个config.toml配置文件，超级简洁。经过与hexo的对比测试，同样的文章数量，在hexo下需要4-5秒的时间来生成网页，而在hugo下不用等待，一回车，网页就生成了。​ 不过Hugo也有一些缺陷，比如说主题质量不如hexo下的好，而且因为大都是欧美的开发者，所以里面使用了大量的google元素，本地化不友好等等。 Hugo建站初始化​ 下面我把自己的建站经历分享给大家。命令 1hugo new site blog ​ 然后会生成blog文件夹。首先要了解它的目录结构 123456789.├── archetypes #文章模板文件夹├── assets├── content #文章/page文件夹├── data├── layouts #html模板文件夹├── static #静态文件，包括图片等，可以包含目录，会直接生成在网站根目录├── themes #主题文件夹└── config.toml #配置文件 ​ 因为Hugo的初始化只是建立了目录结构，并没有文件生成，所以它不像hexo那样开箱即用。也正是因为空目录，所以你要先下载一个主题到themes文件夹内。我用的主题是超简洁的minimal。 ​ 有了主题文件，还要在做一件事，那就是修改配置文件config.toml，加上theme = &quot;minimal&quot;。Hugo不同于Hexo的地方在于，hugo只有一个根目录下的配置文件，而hexo不仅有根目录下的配置文件，还有主题目录里的配置文件。一般的，Hugo的主题文件内都会有一个\exampleSite\文件夹，只要将其中的文件复制到根目录下，就可以预览网页了。没有这个文件夹的，也要把主题内的配置文件内容复制到根目录的config.toml中。 写作​ hugo也提供了hexo类似的方式新建文章 1hugo new posts/my-first-post.md ​ 这样就会在content/posts/下生成my-first-post.md文件。不够我不建议用这样的方式新建文章，因为在hugo下不同的主题可能使用不同的目录来存放文章，比如我用的minimal，它content中只有post、project两个文件夹，而post才是我们日常写文章的存放文件夹。并且hugo必须指定路劲，如果直接用hugo new my-first-post.md文件将生成在content/中，不是像hexo那样生成在source/_posts/中。路径的错误会导致网页跟预期的效果不一样。 ​ 所以，我建议，选好主题后，根据主题的目录，直接在对应的目录中右键新建一个文件。还要注意文章文件名与Front Matter中的title要一致。 ​ 如果文章中有图片，要把图片放到static目录下，最好在static内新建一个与文章同名的文件夹，然后把图片放到里面，这样方便管理。在文章中加入图片 12![hugo](/Hexo与Hugo-静态博客框架选择/hugo.png)推荐用 : &#123;% asset_img 码云.png 代码托管 %&#125; （注意路径前面的/） 生成​ Hugo生成网页很方便。直接使用命令hugo就可以瞬间把文章渲染成网页。另外还有一个非常方便的功能是，hugo内置了网页服务器（都是因为go语言的好处），你可以使用命令hugo server开启服务器，然后就可以使用浏览器查看效果了http://localhost:1313/。并且工程内任何的文件改动都会实时更新预览，这个比起hexo简直方便多了。 部署​ hugo也提供了一些自动部署的工具，我推荐一个通用的方法，使用Rsync方式部署。rsync 是开源的文件增量传输软件，可以用来进行文件的远程复制与备份。 ​ 使用命令 1hugo &amp;&amp; rsync -avz --delete public/ user@host:~/www/ ​ 就可以将文章渲染成网页并同步到host远程主机。 ​ 我用的方式为码云的page服务，将hugo工程托管到码云后，page服务会替你生成网页并给你一个网页空间。具体实现步骤是先在码云上建立一个工程，将hugo上传到工程，然后再服务里找到page按照要求填写一下就可以了，如图 值得一提的是，码云很好用，page支持Jekyll、Hugo、Hexo三种静态博客框架。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>hugo</tag>
        <tag>静态博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CrossTools-Ng]]></title>
    <url>%2F57586%2F</url>
    <content type="text"><![CDATA[在linux下构建交叉编译环境： 1. 安装 Crosstools-ng 下载Crosstoolshttp://crosstool-ng.org/download/crosstool-ng/ 用 ./configure 安装，可能会提示错误，按照错误提示安装依赖关系，其中makeinfo库存在于texinfo软件包中；curses.h存在于libcurses5-dev中。 安装完成后，不会自动将ct-ng程序添加到环境变量里，需要手动添加。ct-ng会列出命令选项 2.构建arm编译环境 运行 ct-ng menuconfig会出现图形化的配置界面。 进入 目标选项 一栏配置目标类型： 目标架构 选择arm，其他的根据需要选择 进入 操作系统 一栏配置目标系统： 在linux下可能没有目标计算机上安装内核版本，选择一个最接近的，即选择内核版本号与主修版本号相同的。 进入 二进制程序 一栏配置binutils：尽量选择高版本的 进入 C库 一栏配置C库版本：C库选择eglibc（嵌入式C库），版本尽量选择目标计算机使用的版本相同 进入 C编译器 一栏配置gcc版本：尽量选择最新版本，同时要编译C++的话，还要选择C++选项 其他的选项都按默认的就好，退出保存配置 然后运行 ct-ng build 构建工具链。此过程需要很长的时间，需要下载很多东西，所以最好单独建立一个目录。在构建的过程中可能会出错，一般为下载错误，很据提示手动下载需要的软件包放到 ～/.build/tarballs目录下，再次build，直到成功。 工具链构建成功后会在home目录下生成 x-tools目录里面有你配置的各种编译环境，arm的为 arm-unkonwn-linux-geabi目录，在里面的bin目录下就是我们熟悉的 gcc g++ 等命令，最好将bin路径存入环境变量，方便使用。 3.构建windows编译环境与arm的类似，将目标架构设为x86，操作系统选择windows。有个小技巧，可以将arm下面～/.build/tarballs里的软件包复制到windows架构目录下，这样可以减少下载。]]></content>
      <tags>
        <tag>网易</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DICOM图像格式]]></title>
    <url>%2F33607%2F</url>
    <content type="text"><![CDATA[从图上可以看出，文件头的Preamble部分00000000H-000007FH的128个字节的值都为00H。在DICOM中，文件头是可选的，它的存在只是为了提供与一些通用的计算机文件格式的兼容性（如BMP文件头为128字节）。接下来的四个ASCII码字符为DICM，为文件头的Prefix部分。00000084H-00000149H为File Meta Element部分，是由一系列的数据元素组合而成的数据集。 第一个数据元素的完整字符数据为：02 00 00 00 55 4C 04 00 BA 00 00 00。由于File Meta Element按照显式小端字序编码，所以Tag改变顺序后2字节组号为：0002，2字节元素号为：0000。根据此Tag(0002,0000)，查表2?4可以知道该数据元素表示的是文件头长度（File Meta Information Group Length）。随后2字节的VR值为：554C，变换成ASCII码为UL，属于表2?6所列举的情况，因此随后的2个字节表示值域长度。值域长度04 00按照编码变换为00 04，表明值域长度为4个字节，因此值域为BA 00 00 00。值域按照编码变换为00 00 00 BA，表示文件头长度为 个字符，即从该数据元素结束地方到最后一个组号为2的数据元素（包括该数据元素）结束的地方之间的字符个数为186个，从图2?4可以知道从00000090H开始到00000149H结束共186个字节。以此类推下去可以解析出每一个数据元素。 几个比较重要的数据元素中，Tag值为(0002,0010)的数据元素定义了组号不为2的数据元素的传输语法，其完整数据为：02 00 10 00 55 49 14 00 31 2E 32 2E 38 34 30 2E 31 30 30 30 38 2E 31 2E 32 2E 31 00。VR为UI属于表2?6的情况，此外UI表示数据类型为UID（唯一标识符）。值域长度为20个字符，值域转换为ASCII码为1.2.840.10008.1.2.1，查表2?3可知传输语法为Explicit VR Little Endian（显式小端字序）。Tag值为(0028,0010)的数据元素定义了图像的行数（图像高度），完整数据为：28 00 10 00 55 53 02 00 00 03，VR属于表2?6所示的情况，图像高度为768个像素。Tag值为(0028,0011)的数据元素定义了图像的行数（图像宽度），完整数据为：28 00 11 00 55 53 02 00 00 04，VR属于表2?6所示的情况，图像宽度为1024个像素。Tag值为(7FE0,0010)定义了像素数据，完整数据为：E0 7F 10 00 4F 42 00 00 00 00 0C 00，VR属于表2?5所示的情况，像素数据为786432个字节。]]></content>
      <tags>
        <tag>网易</tag>
        <tag>DICOM</tag>
        <tag>超声图像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3Q大战]]></title>
    <url>%2F449%2F</url>
    <content type="text"><![CDATA[在中国互联网蓬勃发展的阶段，腾讯和360展开了一场旷日持久的桌面争夺战 腾讯回应致广大QQ用户的一封信 亲爱的QQ用户： 当您看到这封信的时候，我们刚刚作出了一个非常艰难的决定。在360公司停止对QQ进行外挂侵犯和恶意诋毁之前，我们决定将在装有360软件的电脑上停止运行QQ软件。我们深知这样会给您造成一定的不便，我们诚恳地向您致歉。同时也把作出这一决定的原因写在下面，盼望得到您的理解和支持。一、保障您的QQ帐户安全 近期360强制推广并胁迫用户安装非法外挂“扣扣保镖”。该软件劫持了QQ的安全模块，导致了QQ失去相关功能。在360软件运行环境下，我们无法保障您的QQ帐户安全。 二、对没有道德底线的行为说不 360屡屡制造“QQ侵犯用户隐私”的谣言，对QQ的安全功能进行恶意污蔑。事实上QQ安全模块绝没有进行任何用户隐私数据的扫描、监控，更绝对没有上传用户数据。目前我们已经将QQ安全模块代码交由第三方机构检测，以证明我们的清白。 更甚的是，360作为一家互联网安全公司，竟推出外挂软件，公然站到了“安全”的对立面，对其他公司的软件进行劫持和控制。这些都是没有道德底线的行为。 三、抵制违法行为 任何商业行为，无论出于何种目的，都应该在国家法律法规的框架下进行。而360竟然采用“外挂”这种非法手段，破坏腾讯公司的正常运营。 360已经在用户电脑桌面上对QQ发起了劫持和破坏。我们本可以选择技术对抗，但考虑再三，我们还是决定不能让您的电脑桌面成为“战场”，而把选择软件的权利交给您。 十二年来，QQ有幸能陪伴着您成长；未来日子，我们期待与您继续同行！ 腾讯公司2010年11月3日 360回应]]></content>
  </entry>
  <entry>
    <title><![CDATA[ATI_HD2300]]></title>
    <url>%2F43491%2F</url>
    <content type="text"><![CDATA[今帮同学装了个电脑，她的机器有点老，acer官网已停止显卡驱动下载，找了老半天才给她找到ATI HD2300的驱动，再次附上链接，有需要的可以下载， HD2300 安装说明：打开设备管理器（我的电脑-&gt;管理-&gt;设备管理器），点击显示卡，右键单击ATI……，选择更新驱动，选择手动查找，从磁盘安装，浏览找到下载的驱动，选择配置文件CX_63576即可。 驱动地址：http://115.com/file/aq6caxto#hd2300mobilityradeon_v8.491xp.7z]]></content>
  </entry>
  <entry>
    <title><![CDATA[CMake编译VLC-QT]]></title>
    <url>%2F19786%2F</url>
    <content type="text"><![CDATA[为了使用最新的VLC库，需要自己对VLC-QT库进行编译，编译用到了CMake。下面是我的编译过程： 作者给出了一份编译说明文档 Building VLC-QtRequirementsVLC-Qt can be built with any common compiler (g++, clang, MSVC, MinGW).Build files are generated using CMake (3.0.2 or later). All stable versions of VLC since 2.1 work with VLC-Qt.Qt 5 (version 5.5 or later recommende) is recommended as Qt 4 support isconsidered deprecated. Binaries will always be provided for latest Qt versionreleased at the time of release. Make sure you have git submodules initialised or you may experience build issues. CMake configurationThere are some specific CMake flags may need: COVERAGE: generate coverage report, OFF by default DEBUG_SUFFIX: add debug suffix ‘d’ to the libraries, ON on Widows, OFF elsewhere LIBVLC_VERSION: set VLC version you are compiling with to disable unsupported features, should be defined as base 16 integer like `0x020200`, defaults to latest stable VLC version STATIC: build statically, OFF by default SYSTEM_QML: detect and install to system QML location, OFF by default Extra platform specific flags: WITH_GLES: link OpenGL ES v2 on Windows, OFF by default, only needed for Qt 5.4 and lower (deprecated) WITH_HOMEBREW: let system know you are using Homebrew provided Qt, OFF by default, macOS only WITH_X11: link with X11, required by some Linux distributions, OFF by default Building in separate build directory is recommended.There is a test target to run automatic tests for the library. Platform specific instructionsmacOSYou need to prepare VLC libraries and plugins before building. After cmake runmake prepare, then re-run cmake. Build as a normal library or application. Supported generators are make and ninja.Qt in PATH and VLC in /Applications will be used. Make example:123456789&gt; $ export PATH=$PATH:/path/to/Qt/5.6/clang_64/bin&gt; $ mkdir build&gt; $ cd build&gt; $ cmake .. -DCMAKE_BUILD_TYPE=Debug&gt; $ make prepare&gt; $ cmake ..&gt; $ make -j8&gt; $ make install&gt; &gt; WindowsBuild as a normal library or application. Make sure you always use debug libraries with debug build and release librarieswith release build after using it in your project. Supported generators for MSVC are nmake, jom and ninja;for MinGW: mingw32-make and ninja.Run specific Qt shell to select its version. VLC path needs to be specified manually. Ninja example for MSVC64:12345678910&gt; $ md build&gt; $ cd build&gt; $ cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug ^&gt; -DCMAKE_INSTALL_PREFIX=&quot;E:/install/vlc-qt/msvc64&quot; ^&gt; -DLIBVLC_LIBRARY=&quot;E:/vlc/win64/sdk/lib/libvlc.lib&quot; ^&gt; -DLIBVLCCORE_LIBRARY=&quot;E:/vlc/win64/sdk/lib/libvlccore.lib&quot; ^&gt; -DLIBVLC_INCLUDE_DIR=&quot;E:/vlc/win64/sdk/include&quot;&gt; $ ninja&gt; $ ninja install&gt; &gt; LinuxInstall requirements from your distribution’s repository.Supported generators are make and ninja. Make example:123456&gt; $ mkdir build&gt; $ cd build&gt; $ cmake .. -DCMAKE_BUILD_TYPE=Debug&gt; $ make -j8&gt; $ make install&gt; 按照说明，我在win10下结合VS2015进行编译 1. 注意：不要用powershell，要用cmd在源码目录新建一个文件夹（比如 build），在这个文件夹内打开cmd，输入命令 1cmake ../ -GNinja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="F:/VLC-QT/bin" -DLIBVLC_LIBRARY="F:/vlc/sdk/lib/libvlc.lib" -DLIBVLCCORE_LIBRARY="F:/vlc/sdk/lib/libvlccore.lib" -DLIBVLC_INCLUDE_DIR="F:/vlc/sdk/include" 这里用到了Ninja构建系统，下载后放到cmake目录就好了，就是一个单exe文件。这一大串命令可以精简一下，把包含目录和库文件作为变量写进CMakeList.txt文件 123456# 根目录下的CMakeList.txtSET(CMAKE_BUILD_TYPE Release)SET(CMAKE_INSTALL_PREFIX &quot;F:/VLC-QT/bin&quot;)SET(LIBVLC_LIBRARY &quot;F:/qt/sdk/lib/libvlc.lib&quot;)SET(LIBVLCCORE_LIBRARY &quot;F:/qt/sdk/lib/libvlccore.lib&quot;)SET(LIBVLC_INCLUDE_DIR &quot;F:/qt/sdk/include&quot;) 然后执行命令 1cmake ../ -GNinja 就简单多了 其中用到了libvlc的库，需要提前下载，下载地址VLC FTP archive 如果这一步提示错误，找不到编译器 No CMAKE_C_COMPILER could be found. No CMAKE_CXX_COMPILER could be found. ，需要先临时设置一下VS Compiler的环境变量。cd 到 VS VCC的目录，比如C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC ,在这个目录下有一个脚本vcvarsall.bat，稍微看一下这个脚本就知道这是设置vc用到的所有环境变量的。执行： 1vcvarsall.bat x86 #这里将会把文件编译成32位的程序，需要64位的，把参数变成x64或者amd64 然后再次执行上面的cmake命令，这是就会显示 1234-- The C compiler identification is MSVC 19.0.24215.1-- The CXX compiler identification is MSVC 19.0.24215.1-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/cl.exe-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/cl.exe -- works 表示VS2015的编译器已经找到了。 但是又有了新的错误，找不到Qt5CoreConfig.cmake等，因为用到了QT，所以也要把qt库添加进来。 首先找到你的Qt5CoreConfig.cmake所在路径，然后在根目录的CMakeList.txt文件中添加一个变量Qt5Core_DIR，其他类似的错误也是一样的方式添加。 12345678SET(Qt5Core_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Core)SET(Qt5Gui_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Gui)SET(Qt5Network_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Network)SET(Qt5Qml_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Qml)SET(Qt5QuickTest_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5QuickTest)SET(Qt5Quick_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Quick)SET(Qt5Test_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Test)SET(Qt5Widgets_DIR D:/Qt/Qt5.9.1/5.9.1/msvc2015/lib/cmake/Qt5Widgets) 再次cmake就会通过了。 然后执行 1ninja 就开始编译啦。编译完成后，会在build/src目录下看到生成的dll和lib文件。至此VLC-QT库就自己编译好了，可以拿去用啦。 CMake GUI 方式上面是用命令行的方式编译成Ninja工程，这里演示一下用GUI的方式编译为VS2015工程的过程。 GUI方式可以方便的添加环境变量，不用去编辑CMakeList.txt文件。在configure过程中出现的错误一一排除就可以啦。 操作过程视频： 编译效果把编译好的dll放到程序里看看效果吧]]></content>
      <tags>
        <tag>cmake</tag>
        <tag>vlc-qt</tag>
        <tag>ninja</tag>
        <tag>vs2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WoL远程唤醒]]></title>
    <url>%2F11197%2F</url>
    <content type="text"><![CDATA[Wake-on-LAN (WoL) is an Ethernet or Token Ring computer networking standard that allows a computer to be turned on or awakened by a network message.该技术可以用来在远程打开局域网内的电脑。比如在办公室的内放置一个低功耗的树莓派(Raspberry Pi)，并保持运行状态，利用MQTT协议在任何地方向树莓派发送开机指令，然后树莓派就会向办公室的局域网内发送wol广播消息，对应的电脑就会打开。远程唤醒的关键在于几点： 内外网通信 wol魔数包 硬件支持（BIOS设置、系统网卡设置） 内外网通信好在只是传递简单的指令，因此完全可以用mqtt协议。有多家公司和机构都提供了免费的mqtt服务器，完全能够满足要求。如果需要隐私和防护，可以设计一个合适的json格式数据。 wol魔数包wol基于UDP协议，端口号为7或9，发送固定格式的数据包，称为magic packet。packet由16进制数组成，包括都是ff的6个头字节和16次重复的6字节mac地址。packet=0xFF6+mac16例如 123456789101112131415161718UDP Header: |--source ip : 192.168.1.4 |--destination ip : 255.255.255.255 |--src port : 55656 |--dst port : 7 |-UDP length : 116MAC Address: 00-E0-4C-31-03-ACPassword: 00 00 00 00 00 00RAW Data: FF FF FF FF FF FF 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 E0 4C 31 03 AC 00 00 00 00 00 00 实际上，端口号不重要，可以使任意端口。根据协议规定，端口7为Echo Protocol，端口9为WoL。但是网卡只关心魔数包的内容，不管端口号是什么（电脑还没有开机，没有端口号的定义） Wiki的解释：Magic packet The magic packet is a frame that is most often sent as a broadcast and that contains anywhere within its payload 6 bytes of all 255 (FF FF FF FF FF FF in hexadecimal), followed by sixteen repetitions of the target computer’s 48-bit MAC address, for a total of 102 bytes. Since the magic packet is only scanned for the string above, and not actually parsed by a full protocol stack, it could be sent as payload of any network- and transport-layer protocol, although it is typically sent as a UDP datagram to port 0 (reserved port number),7 (Echo Protocol) or 9 (Discard Protocol),or directly over Ethernet as EtherType 0x0842. A connection-oriented transport-layer protocol like TCP is less suited for this task as it requires establishing an active connection before sending user data. 编程实现12345678910# python 3.7import socketmac='00-E0-4C-31-03-AC'sep=mac[2]macaddress = mac.replace(sep, '')packet = bytes.fromhex("ff" * 6 + macaddress * 16)with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock: sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) sock.connect(("192.168.1.255", 9)) sock.send(packet) socket只能发送字节流socket.send(bytes[, flags])，因此要将mac由str转换为bytes。 12&gt;&gt;&gt;bytes.fromhex(&apos;2Ef0 F1f2 &apos;)b&apos;.\xf0\xf1\xf2&apos; bytes.fromhex()方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。 通过bytes.hex()将十六进制数转换为str打印，可以清楚看到packet的内容 12&gt;&gt;&gt; packet.hex()'ffffffffffff00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac00e04c3103ac' 用wireshark监听的结果： 可以看到packet包内的数据和接收到的数据是一致的。 经测试，任意的端口号都可以用。 扩展：广播地址广播地址必须使用UDP协议，工作在局域网中。 255.255.255.255 只能在所在子网中传播，不能被路由器向外发送 192.168.1.255 可以被路由器发送到其他的子网，也可以作为本子网的广播 经测试，在局域网中DHCP协议可以使用255.255.255.255，而用255.255.255.255的WOL协议则被路由器丢弃了，只有用192.168.1.255地址广播才会被路由器转发。因此，未来兼容新，最好使用类似192.168.1.255的地址，不用255.255.255.255。 常用端口列表 Port TCP UDP SCTP DCCP Description 0 Reserved Reserved N/A In programming APIs (not in communication between hosts), requests a system-allocated (dynamic) port[6] 1 Yes Assigned TCP Port Service Multiplexer (TCPMUX). Historic. Both TCP and UDP have been assigned to TCPMUX by IANA,[2] but by design only TCP is specified.[7] 5 Assigned Assigned Remote Job Entry[8] was historically using socket 5 in its old socket form, while MIB PIM has identified it as TCP/5[9] and IANA has assigned both TCP and UDP 5 to it. 7 Yes Yes Echo Protocol[10][11] 9 Yes Yes Yes[12] Discard Protocol[13] No Unofficial Wake-on-LAN[14] 11 Yes Yes Active Users (systat) service)[15][16] 13 Yes Yes Daytime Protocol[17] 15 Unofficial No Previously netstat service[2][15] 17 Yes Yes Quote of the Day (QOTD)[18] 18 Yes Yes Message Send Protocol[19][20] 19 Yes Yes Character Generator Protocol (CHARGEN)[21] 20 Yes Assigned Yes[12] File Transfer Protocol (FTP) data transfer[11] 21 Yes Assigned Yes[12] File Transfer Protocol (FTP) control (command)[11][12][22][23] 22 Yes Assigned Yes[12] Secure Shell (SSH),[11] secure logins, file transfers (scp, sftp) and port forwarding 23 Yes Assigned Telnet protocol—unencrypted text communications[11][24] 25 Yes Assigned Simple Mail Transfer Protocol (SMTP),[11][25] used for email routing between mail servers 28 Unofficial Palo Alto Networks’ Panorama High Availability (HA) sync encrypted port.[26] 37 Yes Yes Time Protocol[27] 42 Assigned Yes Host Name Server Protocol[28] 43 Yes Assigned WHOIS protocol[29][30][31] 47 Reserved Reserved 49 Yes Yes TACACS Login Host protocol.[32] TACACS+, still in draft which is an improved but distinct version of TACACS, only uses TCP 49.[33] 51 Reserved Reserved Historically used for Interface Message Processor logical address management,[34] entry has been removed by IANA on 2013-05-25 52 Assigned Assigned Xerox Network Systems (XNS) Time Protocol. Despite this port being assigned by IANA, the service is meant to work on SPP (ancestor of IPX/SPX), instead of TCP/IP.[35] 53 Yes Yes Domain Name System (DNS)[36][11] 54 Assigned Assigned Xerox Network Systems (XNS) Clearinghouse (Name Server). Despite this port being assigned by IANA, the service is meant to work on SPP (ancestor of IPX/SPX), instead of TCP/IP.[35] 56 Assigned Assigned Xerox Network Systems (XNS) Authentication Protocol. Despite this port being assigned by IANA, the service is meant to work on SPP (ancestor of IPX/SPX), instead of TCP/IP.[35] 58 Assigned Assigned Xerox Network Systems (XNS) Mail. Despite this port being assigned by IANA, the service is meant to work on SPP (ancestor of IPX/SPX), instead of TCP/IP.[35] 61 Reserved Reserved Historically assigned to the NIFTP-Based Mail protocol,[37] but was never documented in the related IEN.[38] The port number entry was removed from IANA’s registry on 2017-05-18.[2] 67 Assigned Yes Bootstrap Protocol (BOOTP) server;[11] also used by Dynamic Host Configuration Protocol (DHCP) 68 Assigned Yes Bootstrap Protocol (BOOTP) client;[11] also used by Dynamic Host Configuration Protocol (DHCP) 69 Assigned Yes Trivial File Transfer Protocol (TFTP)[11][39][40][41] 70 Yes Assigned Gopher) protocol[42] 71–74 Yes Yes NETRJS protocol[43][44][45] 79 Yes Assigned Finger protocol[11][46][47] 80 Yes Yes Yes[12] Hypertext Transfer Protocol (HTTP)[48][49] uses TCP in versions 1.x and 2. HTTP/3 uses QUIC,[50] a transport protocol on top of UDP. 81 Unofficial TorPark onion routing[verification needed] 82 Unofficial TorPark control[verification needed] 83 Yes Assigned MIT ML Device, networking file system[51] 88 Yes Yes Kerberos)[11][52][53] authentication system 90 Unofficial Unofficial PointCast (dotcom))[2][third-party source needed] 95 Yes Assigned SUPDUP, terminal-independent remote login[54] 101 Yes Assigned NIC host name[55] 102 Yes Assigned ISO Transport Service Access Point (TSAP) Class 0 protocol;[56][57] 104 Yes Yes Digital Imaging and Communications in Medicine (DICOM; also port 11112) 105 Yes Yes CCSO Nameserver[58] 107 Yes Yes Remote User Telnet Service (RTelnet)[59] 108 Yes Yes IBM Systems Network Architecture (SNA) gateway access server 109 Yes Assigned Post Office Protocol, version 2 (POP2)[60] 110 Yes Assigned Post Office Protocol, version 3 (POP3)[11][61][62] 111 Yes Yes Open Network Computing Remote Procedure Call (ONC RPC, sometimes referred to as Sun RPC) 113 Yes No Ident, authentication service/identification protocol,[11][63] used by IRC servers to identify users Yes Assigned Authentication Service (auth), the predecessor to identification protocol. Used to determine a user’s identity of a particular TCP connection.[64] 115 Yes Assigned Simple File Transfer Protocol[11][65] 117 Yes Yes UUCP Mapping Project (path service)[citation needed] 118 Yes Yes Structured Query Language (SQL) Services[jargon] 119 Yes Assigned Network News Transfer Protocol (NNTP),[11] retrieval of newsgroup messages[66][67] 123 Assigned Yes Network Time Protocol (NTP), used for time synchronization[11] 126 Yes Yes Formerly Unisys Unitary Login, renamed by Unisys to NXEdit. Used by Unisys Programmer’s Workbench for Clearpath MCP, an IDE for Unisys MCP software development 135 Yes Yes DCE endpoint resolution Yes Yes Microsoft EPMAP (End Point Mapper), also known as DCE/RPC Locator service,[68] used to remotely manage services including DHCP server, DNS server and WINS. Also used by DCOM 137 Yes Yes NetBIOS Name Service, used for name registration and resolution)[69][70] 138 Assigned Yes NetBIOS Datagram Service[11][69][70] 139 Yes Assigned NetBIOS Session Service[69][70] 143 Yes Assigned Internet Message Access Protocol (IMAP),[11] management of electronic mail messages on a server[71] 152 Yes Yes Background File Transfer Program (BFTP)[72][importance?] 153 Yes Yes Simple Gateway Monitoring Protocol (SGMP), a protocol for remote inspection and alteration of gateway management information[73] 156 Yes Yes Structured Query Language (SQL) Service[jargon] 158 Yes Yes Distributed Mail System Protocol (DMSP, sometimes referred to as Pcmail)[74][importance?] 161 Assigned Yes Simple Network Management Protocol (SNMP)[75][citation needed][11] 162 Yes Yes Simple Network Management Protocol Trap (SNMPTRAP)[75][76][citation needed] 170 Yes Yes Network PostScript print server 177 Yes Yes X Display Manager Control Protocol (XDMCP), used for remote logins to an X Display Manager) server[77][self-published source] 179 Yes Assigned Yes[12] Border Gateway Protocol (BGP),[78] used to exchange routing and reachability information among autonomous systems) (AS) on the Internet 194 Yes Yes Internet Relay Chat (IRC)[79] 199 Yes Yes SNMP Unix Multiplexer (SMUX)[80] 201 Yes Yes AppleTalk Routing Maintenance 209 Yes Assigned Quick Mail Transfer Protocol[81][self-published source] 210 Yes Yes ANSI Z39.50 213 Yes Yes Internetwork Packet Exchange (IPX) 218 Yes Yes Message posting protocol (MPP) 220 Yes Yes Internet Message Access Protocol (IMAP), version 3 225–241 Reserved Reserved 249–255 Reserved Reserved 259 Yes Yes Efficient Short Remote Operations (ESRO) 262 Yes Yes Arcisdms 264 Yes Yes Border Gateway Multicast Protocol (BGMP) 280 Yes Yes http-mgmt 300 Unofficial ThinLinc Web Access 308 Yes Novastor Online Backup 311 Yes Assigned macOS Server Admin[11] (officially AppleShare IP Web administration[2]) 318 Yes Yes PKIX Time Stamp Protocol (TSP) 319 Yes Precision Time Protocol (PTP) event messages 320 Yes Precision Time Protocol (PTP) general messages 350 Yes Yes Mapping of Airline Traffic over Internet Protocol (MATIP) type A 351 Yes Yes MATIP type B 356 Yes Yes cloanto-net-1 (used by Cloanto Amiga Explorer and VMs) 366 Yes Yes On-Demand Mail Relay (ODMR) 369 Yes Yes Rpc2portmap 370 Yes Yes codaauth2, Coda authentication server Yes securecast1, outgoing packets to NAI‘s SecureCast servers[82]As of 2000 371 Yes Yes ClearCase albd 376 Yes Yes Amiga Envoy Network Inquiry Protocol 383 Yes Yes HP data alarm manager 384 Yes Yes A Remote Network Server System 387 Yes Yes AURP (AppleTalk Update-based Routing Protocol)[83] 388 Yes Assigned Unidata LDM near real-time data distribution protocol[84][self-published source][85][self-published source] 389 Yes Assigned Lightweight Directory Access Protocol (LDAP)[11] 399 Yes Yes Digital Equipment Corporation DECnet+ (Phase V) over TCP/IP (RFC1859) 401 Yes Yes Uninterruptible power supply (UPS) 427 Yes Yes Service Location Protocol (SLP)[11] 433 Yes Yes NNTP, part of Network News Transfer Protocol 434 Yes Yes Mobile IP Agent (RFC 5944) 443 Yes Yes Yes[12] Hypertext Transfer Protocol Secure (HTTPS)[48][49] uses TCP in versions 1.x and 2. HTTP/3 uses QUIC,[50] a transport protocol on top of UDP. 444 Yes Yes Simple Network Paging Protocol (SNPP), RFC 1568 445 Yes Yes Microsoft-DS (Directory Services) Active Directory,[86] Windows shares Yes Assigned Microsoft-DS (Directory Services) SMB[11] file sharing 464 Yes Yes Kerberos) Change/Set password 465 Yes No URL Rendezvous Directory for SSM (Cisco protocol)[importance?] Yes No Authenticated SMTP[11] over TLS/SSL (SMTPS)[87] 475 Yes Yes tcpnethaspsrv, Aladdin Knowledge Systems Hasp services 476–490 Unofficial Unofficial Centro Software ERP ports 491 Unofficial GO-Global remote access and application publishing software 497 Yes Yes Retrospect) 500 Assigned Yes Internet Security Association and Key Management Protocol (ISAKMP) / Internet Key Exchange (IKE)[11] 502 Yes Yes Modbus Protocol 504 Yes Yes Citadel, multiservice protocol for dedicated clients for the Citadel groupware system 510 Yes Yes FirstClass Protocol (FCP), used by FirstClass client/server groupware system 512 Yes Rexec, Remote Process Execution Yes comsat, together with biff) 513 Yes rlogin Yes Who[88] 514 Unofficial Remote Shell, used to execute non-interactive commands on a remote system (Remote Shell, rsh, remsh) No Yes Syslog,[11] used for system logging 515 Yes Assigned Line Printer Daemon (LPD),[11] print service 517 Yes Talk 518 Yes NTalk 520 Yes efs, extended file name server Yes Routing Information Protocol (RIP) 521 Yes Routing Information Protocol Next Generation (RIPng) 524 Yes Yes NetWare Core Protocol (NCP) is used for a variety things such as access to primary NetWare server resources, Time Synchronization, etc. 525 Yes Timed, Timeserver 530 Yes Yes Remote procedure call (RPC) 532 Yes Assigned netnews[11] 533 Yes netwall, For Emergency Broadcasts 540 Yes Unix-to-Unix Copy Protocol (UUCP) 542 Yes Yes commerce (Commerce Applications) 543 Yes klogin, Kerberos) login 544 Yes kshell, Kerberos) Remote shell 546 Yes Yes DHCPv6 client 547 Yes Yes DHCPv6 server 548 Yes Assigned Apple Filing Protocol (AFP) over TCP[11] 550 Yes Yes new-rwho, new-who[88] 554 Yes Yes Real Time Streaming Protocol (RTSP)[11] 556 Yes Remotefs, RFS, rfs_server 560 Yes rmonitor, Remote Monitor 561 Yes monitor 563 Yes Yes NNTP over TLS/SSL (NNTPS) 564 Unofficial 9P) (Plan 9) 585 No No Previously assigned for use of Internet Message Access Protocol over TLS/SSL (IMAPS), now deregisterd in favour of port 993.[89] 587 Yes Assigned email message submission[11][90] (SMTP) 591 Yes FileMaker 6.0 (and later) Web Sharing (HTTP Alternate, also see port 80) 593 Yes Yes HTTP RPC Ep Map, Remote procedure call over Hypertext Transfer Protocol, often used by Distributed Component Object Model services and Microsoft Exchange Server 601 Yes Reliable Syslog Service — used for system logging 604 Yes TUNNEL profile,[91] a protocol for BEEP peers to form an application layer tunnel 623 Yes ASF Remote Management and Control Protocol (ASF-RMCP) &amp; IPMI Remote Management Protocol 625 Unofficial No Open Directory Proxy (ODProxy)[11] 631 Yes Yes Internet Printing Protocol (IPP)[11] Unofficial Unofficial Common Unix Printing System (CUPS) administration console (extension to IPP) 635 Yes Yes RLZ DBase 636 Yes Assigned Lightweight Directory Access Protocol over TLS/SSL (LDAPS)[11] 639 Yes Yes Multicast Source Discovery Protocol, MSDP 641 Yes Yes SupportSoft Nexus Remote Command (control/listening), a proxy gateway connecting remote control traffic 643 Yes Yes SANity 646 Yes Yes Label Distribution Protocol (LDP), a routing protocol used in MPLS networks 647 Yes DHCP Failover protocol[92] 648 Yes Registry Registrar Protocol (RRP)[93] 651 Yes Yes IEEE-MMS 653 Yes Yes SupportSoft Nexus Remote Command (data), a proxy gateway connecting remote control traffic 654 Yes Media Management System (MMS) Media Management Protocol (MMP)[94] 655 Yes Yes Tinc) VPN daemon 657 Yes Yes IBM RMC (Remote monitoring and Control) protocol, used by System p5 AIX Integrated Virtualization Manager (IVM)[95] and Hardware Management Console to connect managed logical partitions (LPAR) to enable dynamic partition reconfiguration 660 Yes Assigned macOS Server administration,[2] version 10.4 and earlier[11] 666 Yes Yes Doom), first online first-person shooter Unofficial airserv-ng, aircrack-ng‘s server for remote-controlling wireless devices 674 Yes Application Configuration Access Protocol (ACAP) 688 Yes Yes REALM-RUSD (ApplianceWare Server Appliance Management Protocol) 690 Yes Yes Velneo Application Transfer Protocol (VATP) 691 Yes MS Exchange Routing 694 Yes Yes Linux-HA high-availability heartbeat 695 Yes IEEE Media Management System over SSL (IEEE-MMS-SSL)[96] 698 Yes Optimized Link State Routing (OLSR) 700 Yes Extensible Provisioning Protocol (EPP), a protocol for communication between domain name registries and registrars (RFC 5734) 701 Yes Link Management Protocol (LMP),[97] a protocol that runs between a pair of nodes) and is used to manage traffic engineering (TE) links 702 Yes IRIS[98][99] (Internet Registry Information Service) over BEEP (Blocks Extensible Exchange Protocol)[100] (RFC 3983) 706 Yes Secure Internet Live Conferencing) (SILC) 711 Yes Cisco Tag Distribution Protocol[101][102][103]—being replaced by the MPLS Label Distribution Protocol[104] 712 Yes Topology Broadcast based on Reverse-Path Forwarding routing protocol (TBRPF; RFC 3684) 749 Yes Yes Kerberos (protocol)) administration[11] 750 Yes kerberos-iv, Kerberos) version IV 751 Unofficial Unofficial kerberosmaster, [Kerberos](https://en.wikipedia.org/wiki/Kerberos(protocol)) authentication 752 Unofficial passwdserver, [Kerberos](https://en.wikipedia.org/wiki/Kerberos(protocol)) password (kpasswd) server 753 Yes Yes Reverse Routing Header (RRH)[105] Unofficial userregserver, [Kerberos](https://en.wikipedia.org/wiki/Kerberos(protocol)) userreg server 754 Yes Yes tell send Unofficial krb5prop, [Kerberos](https://en.wikipedia.org/wiki/Kerberos(protocol)) v5 slave propagation 760 Unofficial Unofficial krbupdate [kreg], Kerberos) registration 782 Unofficial Conserver serial-console management server 783 Unofficial SpamAssassin spamd daemon 800 Yes Yes mdbs-daemon 802 Yes Yes MODBUS/TCP Security[106] 808 Unofficial Microsoft Net.TCP Port Sharing Service 829 Yes Assigned Certificate Management Protocol[107] 830 Yes Yes NETCONF over SSH 831 Yes Yes NETCONF over BEEP 832 Yes Yes NETCONF for SOAP over HTTPS 833 Yes Yes NETCONF for SOAP over BEEP 843 Unofficial Adobe Flash[108] 847 Yes DHCP Failover protocol 848 Yes Yes Group Domain Of Interpretation (GDOI) protocol 853 Yes Yes DNS over TLS (RFC 7858) 860 Yes iSCSI (RFC 3720) 861 Yes Yes OWAMP control (RFC 4656) 862 Yes Yes TWAMP control (RFC 5357) 873 Yes rsync file synchronization protocol 888 Unofficial cddbp, CD DataBase (CDDB) protocol (CDDBP) Unofficial IBM Endpoint Manager Remote Control 897 Unofficial Unofficial Brocade SMI-S RPC 898 Unofficial Unofficial Brocade SMI-S RPC SSL 902 Unofficial Unofficial VMware ESXi[109][110] 903 Unofficial VMware ESXi[109][110] 953 Yes Reserved BIND remote name daemon control (RNDC)[111][112] 981 Unofficial Remote HTTPS management for firewall devices running embedded Check Point VPN-1 software[113] 987 Unofficial Microsoft Remote Web Workplace, a feature of Windows Small Business Server[114] 989 Yes Yes FTPS Protocol (data), FTP over TLS/SSL 990 Yes Yes FTPS Protocol (control), FTP over TLS/SSL 991 Yes Yes Netnews Administration System (NAS)[115] 992 Yes Yes Telnet protocol over TLS/SSL 993 Yes Assigned Internet Message Access Protocol over TLS/SSL (IMAPS)[11] 994 Reserved Reserved Previously assigned to Internet Relay Chat over TLS/SSL (IRCS), but was not used in common practice. 995 Yes Yes Post Office Protocol 3 over TLS/SSL (POP3S)[11] 1010 Unofficial ThinLinc web-based administration interface[116] 1011–1020 Reserved Reserved 1023 Reserved Reserved [2] Unofficial Unofficial z/OS Network File System (NFS) (potentially ports 991–1023)[79][80][117]]]></content>
      <tags>
        <tag>wol</tag>
        <tag>wake on lan</tag>
        <tag>远程唤醒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Matlab添加好看的程序员字体]]></title>
    <url>%2F4205%2F</url>
    <content type="text"><![CDATA[觉得matlab默认字体不好看的小伙伴们有福利了，我搜集了两款专为程序员设计的等宽字体，并且能够完美显示中文。这两款字体分别为： YaHei Consolas Hybrid 和 Source_Code_Pro接下来介绍如何在Windows和Linux下安装 给Matlab安装字体其实就是为了支持中文，因为好多好看的程序员字体都不能显示中文。如果用全英文的话，就不用下面的方法了，直接双击字体文件然后安装就可以了。 首先下载字体。百度不到的小伙伴可以从我分享的百度网盘中下载 字体1链接：https://pan.baidu.com/s/1B2xYJHVwLBmP_w-4Cjg4YA提取码：4dvh字体2链接：https://pan.baidu.com/s/1nTvYbom0OVe53ANY_59FdA提取码：7b3n Windows 安装右键选择 为所有用户安装，否则matlab里面找不到新安装的字体 Linux 安装将中文字体拷贝到matlab安装目录：$MATLAB//sys/java/jre/glnxa64/jre/lib/fonts/fallback/没有fallback目录的自己新建一个然后生成字体配置文件，命令 mkfontscale然后把字体文件复制到上一层目录，即 $MATLAB//sys/java/jre/glnxa64/jre/lib/fonts所有过程如下： 123456cd $MATLAB//sys/java/jre/glnxa64/jre/lib/fontsmkdir fallback;cd fallback;cp font_path/chinese_font.ttf .mkfontscalecp chinese_font.ttf ../ Matlab中选择字体matlab中, 主页-&gt;预设-&gt;matlab-&gt;字体-&gt;自定义,（选择对应的中文字体）设置后保存即可。]]></content>
      <tags>
        <tag>matlab</tag>
        <tag>中文字体</tag>
        <tag>等宽字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker小试]]></title>
    <url>%2F22851%2F</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，类似于虚拟机，但是docker比虚拟机更轻更简洁，非常适合快速部署跨平台的应用。 使用在Ubuntu上做了几个小测试，大体上能够了解Docker怎么用了。 首先安装docker在Ubuntu上用 apt install docker.io，在其他系统上软件包名字会有所不同 构建docker image docker采用了类似增量构建的方式，一层一层的在base image上添加功能。base image是各个linux发行版的最小镜像，由docker官方提供。我们在base image的基础上实现自己的功能。 docker使用Dockerfile构建image 1234567891011121314151617181920212223242526272829303132333435#选择一个基础镜像，alpine是一个体积非常小的linux系统FROM alpine:3.9#在构建阶段，在系统里执行命令#安装软件，alpine的包管理器为apk#RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositoriesRUN apk updateRUN apk add pythonRUN apk add wget#从其他地方获取文件RUN wget --no-check-certificate https://github.com/shadowsocksr-backup/shadowsocksr/archive/3.1.2.tar.gz -O /tmp/3.1.2.tar.gzRUN tar -xf /tmp/3.1.2.tar.gz -C /tmp/RUN mv /tmp/shadowsocksr-3.1.2/shadowsocks/ /usr/local/# 设置环境变量，构建时和运行时都有效ENV port 8888ENV password 888888888ENV method aes-256-cfbENV protocol auth_aes128_md5ENV obfs plainENV obfs_param []#设置工作路径WORKDIR /usr/local/shadowsocks/#运行时执行的命令CMD python server.py -p $port -k $password -m $method -O $protocol -o $obfs -G $obfs_param#构建命令#docker build -t ssr/alpine:1.0 .#设置该image的tag为ssr/alpine 版本为1.0，版本不同image不同#运行#docker run --restart=always --env password=qwerasd -p 8888:8888 ssr/alpine:1.0#通过--env传递环境变量 123456789101112131415161718#另一种方式FROM alpine:3.9#如果速度慢，替换更新源为阿里云RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositoriesRUN apk updateRUN apk add python#从本地复制到image内，#注意copy不会复制最外层目录，只会复制该目录内的内容（文件和文件夹），所有要在destination加一个文件夹COPY ./shadowsocks/ /usr/local/shadowsocks/WORKDIR /usr/local/shadowsocks/#另一种运行方式ENTRYPOINT ["python", "server.py"]#运行#sudo docker run -p 34567:34567 ssr -p 34567 -k 1234567#使用原生方式设置参数 如果用配置文件的方式设置参数 123456789101112131415161718FROM alpine:3.9RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositoriesRUN apk updateRUN apk add python#从本地复制到image内，#注意copy不会复制最外层目录，只会复制该目录内的内容（文件和文件夹），所有要在destination加一个文件夹COPY ./shadowsocks/ /usr/local/shadowsocks/COPY ./s.conf /usr/local/shadowsocks/conf/s.confWORKDIR /usr/local/shadowsocks/#另一种运行方式ENTRYPOINT ["python", "server.py"]#运行#sudo docker run -p 34567:34567 -v /data/conf/s.conf:/usr/local/shadowsocks/conf/s.conf ssr -c conf/s.conf#用-v将外部配置文件挂在到容器里，只能用文件夹挂载，只能是绝对路径#错错错 -v s.conf:/usr/local/shadowsocks/s.conf ssr -c s.conf 错错错 部署运行容器 可以用自己构建的image为模板部署容器 docker run —restart=always —env password=qwerasd -p 8888:8888 ssr/alpine:1.0 —restart=always 系统重启后，docker也会自动重启容器。否则不会自动启动 也可以从docker hub下载别人构建好的image docker pull wordpress docker run wordpress 可以直接run，如果本地没有对应的image则会从hub下载 常用命令 sudo docker images 查看有效的镜像 sudo docker images -a 查看系统中所有镜像 sudo docker rmi xxx 删除ID为xxx镜像 sudo docker rmi ssr/alpine:3.9 使用tag删除镜像 sudo docker ps 查看运行中的容器 sudo docker ps -a 查看所有容器 sudo docker kill xxx 关闭ID为XXX容器 sudo docker rm xxx 删除ID为XXX容器 sudo docker run XXXX 运行容器 替换快速docker源123456# 创建或修改 /etc/docker/daemon.json 文件，重启服务&#123; "registry-mirrors" : [ "http://hub-mirror.c.163.com" ]&#125;]]></content>
      <tags>
        <tag>docker</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给软件加上数字签名]]></title>
    <url>%2F5074%2F</url>
    <content type="text"><![CDATA[数字签名是一种权利保护手段，也是一种安全验证措施。在网络中扮演极其重要的角色。 由于需要在Windows平台上给自主软件进行签名，查阅资料，主要借鉴了 makecert 制作数字证书 和 使用SignTool.exe对文件进行数字签名两篇博文，成功完成签名。 本文记录一下签名的过程。 在Windows下微软提供了一套完整的数字签名套件，一般包含在Windows SDK中，可参考 https://docs.microsoft.com/zh-cn/windows-hardware/drivers/devtest/tools-for-signing-drivers 。 主要用到了四个工具：makecert.exe、cert2spc.exe、pvk2pfx.exe 和 signtool.exe。Windows SDK太大，也可以去网上下载单独的exe程序和相应的dll库。 主要步骤： 1.自制数字证书用于代码签名的数字证书目前没有免费的，有能力的可以去购买。做实验的话，就自己生成一份自签名证书就OK了。signtool签名工具需要pfx格式的证书，因此下面主要是制作一个pfx的证书。Windows SDK内的四个exe都是命令行形式的，看一下帮助信息也不太难。 (1) 首先制作一份通用的自签名证书cer。用makecert，中间会要求输入密码，假设为123 makecert.exe -r -n &quot;CN=宇宙香烟厂&quot; -sv path/yuzhou.pvk path/yuzhou.cer 123456789101112131415MakeCert用于创建x.509标准的证书。命令格式MakeCert [/b DateStart] [/e DateEnd] [/len KeyLength] [/m nMonths] [/n &quot;Name&quot;] [/pe] [/r] [/sc SubjectCertFile] [/sk SubjectKey] [/sr SubjectCertStoreLocation] [/ss SubjectCertStoreName] [/sv SubjectKeyFile] OutputFile -r 表示自签名 -n 表示证书名称 -sv 表示指定保存私钥pvk文件的名称 OutputFile 生成的cer证书的文件的名称 其中证书名称符合X.500标准 [参考1](https://zhuanlan.zhihu.com/p/165306642) [参考2](https://tools.ietf.org/rfc/rfc5280.txt)，常用的有 国家（countryName，C）， 组织（organizationName，O）， 组织单位（organizationalUnitName，OU）， 专有名称限定符（dnQualifier）， 州或省名（stateOrProvinceName，ST）， 通用名称（commonName，CN 这样就得到了通用证书文件yuzhou.cer和对应的私钥文件yuzhou.pvk (2) 将cer证书转换为SPC发布者证书 cert2spc.exe path/yuzhou.cer path/yuzhou.spc这样就得到了发布者证书yuzhou.spc (3) 将公钥(SPC)和私钥合并为一个windows格式的包含私钥的证书pfx pvk2pfx.exe -pvk path/yuzhou.pvk -spc path/yuzhou.spc -pi 123 -pfx path/yuzhou.pfx12345Pvk2Pfx将.spc、.cer和.pvk 文件中包含的公钥和私钥信息复制到个人信息交换文件.pfx中。命令格式pvk2pfx /pvk pvkfilename.pvk [/pi pvkpassword] /spc spcfilename.ext [/pfx pfxfilename.pfx [/po pfxpassword] ] -pfx 表示生成的pfx文件名 -po 表示pfx的加密密码，如果忽略，则使用原来pvk私钥的密码(-pi) 也可以省去第2步，直接用pvk和cer生成pfx。只要把-spc的输入换为cer文件即可pvk2pfx.exe -pvk path/yuzhou.pvk -spc path/yuzhou.cer -pi 123 -pfx path/yuzhou.pfx 这样一份用于代码签名的数字证书yuzhou.pfx就做好了 2.用数字证书签名并打上时间戳SignTool用于对文件进行数字签名，验证文件中的签名和时间戳文件。signtool.exe sign -f path/yuzhou.pfx -p 123 /t http://timestamp.digicert.com path/bin.exe 123/f 指定PFX文件/P 指定打开PFX文件时要使用的密码/T 指定时间戳服务器的 URL。 如果未提供此选项，则签名文件不是时间戳。 这样文件就被证书签名并打上了时间戳。别人想假冒你也假冒不了了。 效果demo文件 没有签名之前 签名之后 可以看到exe文件有了数字签名和时间戳 注意：SignTool只能对windows平台的可执行文件exe、dll进行签名，不能处理linux等其他平台的可执行文件 扩展走过的坑：沃通有一个签名工具 wosigncode.exe ，但是它总是报错说证书类型不匹配，希望沃通能修复这个bug。加密 和 签名加密：通过一种算法将一个数变成另一个数，目的是为了原数据的保密，使其在没有密码的情况下无法得知原文内容； 签名：通常伴随着摘要提取算法（比如md5、sha1、sha2等哈希算法），所有者A对全文或摘要用私钥进行加密，并把加密后的信息和原文一起发送给目标B。目的是保证原文的完整性、防纂改。因为原文一旦有变化，md5值就会有明显的变化，通过比对A发来的解密后的摘要和B自己对原文生成的摘要就能知道原文有没有改变。同时B只能用A的公钥才能解密出A发来的加密摘要，保证了来源的真实性，防止纂改。 比较可知，加密和签名是不同的操作，有不同的目的。加密就是防止原文被偷窥；签名也用到了加密，但目的不是防止原文被偷窥，而是防止原文被纂改。 公钥 和 私钥X509是公钥证书的标准格式。公钥证书是非对称加密的一种方式，即加密解密用不同的密码。非对称机密算法主要使用RSA算法，即生成公钥和私钥一对密码，公钥和私钥一一对应；用公钥加密的数据只能用对应的私钥解密，同样，用私钥加密的数据也只能用对应的公钥。 对称加密（比如AES）就是加密解密都用同一个密码。 SSL证书 和 代码签名证书SSL证书 在HTTPS通信中的SSL协议，就是使用了RSA非对称加密算法。服务器端的公钥和网站证书是公开的，任何人都可以获取，但是服务器的私钥是保密的，放在安全的地方。 虽然SSL通信的基础是RSA非对称加密算法，但是在建立通信后却不用RSA算法了。一是因为RSA算法的计算量大，速度慢；二是因为公钥是公开的，私钥是服务器保密的，这样就只能由用户向服务器发送保密数据，而服务器不能向用户发送保密数据，因为用户用公钥加密数据后，只能用服务器的私钥解密，而私钥只有服务器拥有，数据是安全的；而服务器用私钥加密的数据，能够被所有拥有公钥的人解密，而公钥任何人都能获取，数据等于没有加密。所以SSL中是非对称加密、对称加密、密钥交换算法等一系列算法的共同参与。 简单说明HTTPS通信的过程： 1.当浏览器访问网站时，首先下载网站的公钥和证书，通过CA机构验证证书确实属于该网站后才进行后续的数据通信；并确定加密套件 2.浏览器向服务器发送一个随机数cr 3.服务器也生成一个随机数sr，并生成DH算法的交换参数sdh，然后将cr、sr、sdh一起用私钥签名后发送给浏览器 4.浏览器用公钥验证cr、sr、sdh的真实性，如果cr没有篡改则表明通信安全。然后也生成自己的DH算法的交换参数cdh，并用公钥加密后（也可以不加密）发送给服务器 5.服务器和浏览器都用cdh和sdh生成DH算法最后的密钥ps，DH算法的特性保证了两端能够生成相同的密钥ps，这个密钥只有通信双方知道，其他人是无法获得的，也无法通过前面的cr、sr、sdh、cdh等参数计算出来 6.服务器和浏览器将cr、sr、ps合在一起用加密套件确定的算法（一般为伪随机函数）生成相同的密码key，作为对称加密的密码。这个密码同样也只有双方知道，其他人也无法计算出来 7.随后的数据，双方都用对称加密算法的key加密解密数据。 代码签名证书 代码签名是对可执行文件或脚本进行数字签名以确认软件作者及保证软件在签名后未被修改或损坏的措施。此措施使用加密散列来验证真实性和完整性。 作者用自己的证书私钥加密文件的摘要作为签名，然后将签名集成到文件中。也可以打上时间戳，证明文件发布的时间。 用户下载该文件后，可以查看文件的签名，用作者的公钥解密出摘要。如果文件被篡改了，则摘要将不一样，表明文件有问题了。 因为私钥加密后的数据，拥有公钥只能查看，不能更改，这也就保证了只有原作者才能修改。如果其他人修改原文件或者摘要，则公钥解密摘要后的结果与文件摘要运算后的结果是不一样的。 可以看出SSL证书和代码签名证书的使用场景不一样，不能混用。 linux下的数字签名在linux下一般用openssl套件，用私钥加密/签名文件摘要，用公钥验证。 买不起数字签名证书的可以用openssl自制一份1 生成私钥openssl genpkey -out privkey.pem生成的privkey.pem文件内容如下——-BEGIN RSA PRIVATE KEY——-MIIEpAIBAAKCAQEAkzVWCEgUnVlhwQ8VEfs2Wmi6srTjrhlPiNUhM0D8x8k0hJtKrmBgzxHRkyzgBlRdhHqosQ/M81cnV0dxO87jwvAnavlabza965qMDqAZeTnP+5/n 2 从私钥中提取公钥openssl rsa -in privkey.pem -outform PEM -pubout -out pubkey.pem生成的pubkey.pem文件内容如下——-BEGIN PUBLIC KEY——-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA30YfoyFXaqND++XyyjbanCO45yCI7mydN6AzRzblFxs6YFv9Dlh14D9ZkFENuMLqWsIM+OEPm0BfI+gTC9sf 签名1 用私钥对文件摘要签名openssl dgst -sha256 -sign privkey.pem -out myfile.sign myfile 2 用公钥对文件摘要验证openssl dgst -sha256 -verify pubkey.pem -signature myfile.sign myfile如果正确则Verified OK，否则Verification Failure 也可以用rsautl套件签名1 私钥签名openssl rsautl -sign -inkey privkey.pem -in myfile -out myfile.sign 2 公钥验证openssl rsautl -verify -inkey pubkey.pem -pubin -in myfile.sign -out myfile.vdiff myfile myfile.v但是这种方式有文件大小的限制，也就是还要先对文件生成摘要，然后对摘要签名。对于小文件，rsautl就是直接用私钥将小文件加密成文件副本，然后用公钥把文件副本还原成文件，比较得到的文件和原文件是否一致。为什么只能直接加密小文件，这是加密原理确定的，数据长度不能大于密钥长度，否则就要分组了。 可以看到，linux下的文件签名是单独生成了一个签名文件，并没有将签名信息附加到原文件内。对比windows下，查看exe文件的属性就能看到签名信息。这是因为linux下的可执行文件格式ELF目前还没有统一的标准存放签名信息，但是有人尝试对ELF扩展两个段，存放签名，并且从内核上支持读取验证这两个段，比如我看到的一篇文献]]></content>
      <tags>
        <tag>数字签名</tag>
        <tag>代码签名</tag>
        <tag>signtool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量下载HLS的TS文件并无损合并]]></title>
    <url>%2F39598%2F</url>
    <content type="text"><![CDATA[HLS流媒体协议实际上就是将视频文件切成一系列很短的小视频片段文件，一般为TS文件，即”Transport Stream”的缩写，特点就是要求从视频流的任一片段开始都是可以独立解码的。也就是说直接从服务器下载TS文件，不用经过任何处理就能用常见的播放器播放。通俗的说，HLS协议使我们在网上看电影时能够边下边播，不必把完整的电影下载完再播放，类似于迅雷的边下边播。同时HLS也有一定强度的资源保护能力，因为如果你想把电影下载到本地的话，一般人只能下载一段几秒钟的视频碎片，稍微动手能力强的能够下载一批几秒钟的视频碎片，再强一点的才能够将这一批视频碎片组成一个完成的电影。 学习的需要，用Python写了一个批量下载TS碎片的脚本，仅供大家参考。 原理：1 先在网站上找到视频地址，即m3u8的uri这要自己动手找，不同的网站有不同的策略，有些还会隐藏起来，我这里以一个电影网站为例说明一个常用的方法—调试JS用chrome浏览器打开一个视频网页，按F12进入控制台模式。观察发现网页播放器的初始化过程在一个share.js文件里简单看一下就明白了，url变量就是m3u8的地址，在url这里打个中断点准备调试，刷新网页，等一下就会在断点处停下来，这样url的内容就一目了然了。我测试的url为https://zy.kubo-360-tudou.com/20180903/18448_bad28deb/index.m3u8?sign=5ccfa8c3458e3fc929fe93d5bb022065打开这个网址就会下载一个m3u8文件，文件的内容如下： 123#EXTM3U#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=800000,RESOLUTION=1080x608800k/hls/index.m3u8 ​ 这表示刚才下载的m3u8文件还有一个重定向，指向另一个m3u8文件。把这里两个地址组合一下 https://zy.kubo-360-tudou.com/20180903/18448_bad28deb/800k/hls/index.m3u8 ，然后打开新的网址又下载一个文件，内容如下： 1234567891011121314#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:9#EXT-X-MEDIA-SEQUENCE:0#EXTINF:6.630300,09c7610a2da000.ts#EXTINF:5.212500,09c7610a2da001.ts#EXTINF:4.753800,09c7610a2da002.ts#EXTINF:5.212500,09c7610a2da003.ts............ 这才是真实的TS碎片地址，组合一下地址，就可以直接下载了。比如要下载09c7610a2da003.ts这个文件，打开 https://zy.kubo-360-tudou.com/20180903/18448_bad28deb/800k/hls/09c7610a2da003.ts 就会下载了。 到这里你就可以一个一个把TS视频文件下载下来了，当然这样手动太麻烦，接下来用脚本批量下载。 2 自动解析m3u8文件，获取每一个TS的url这里用到了一个m3u8解析库 Python m3u8 parser（https://pypi.org/project/m3u8/）。使用也很简单 123456import m3u8 playlist = m3u8.load(&apos;http://videoserver.com/playlist.m3u8&apos;) # 从网站下载并解析m3u8文件#注意用不要用需要重定向的地址s=playlist.segments # 得到一个TS片段的对象数组t=s[0] # 得到第一个ts片段的对象t.absolute_uri #得到第一个ts片段的网址，用这个网址就能下载ts视频片段了 3 下载TS这里用到另一个python库 requests https://requests.readthedocs.io/en/master/ 。使用也很简单，用get方式就可以了 123456import requestsr = requests.get(&apos;https://tudou.com/003.ts &apos;) # 访问网址并接收返回的数据r.content # 返回文件的内容with open(fname,&apos;wb&apos;) as f: f.write(r.content) # 以二进制的形式写入本地文件 4 合并成一个完整的电影这里用ffmpeg库，推荐用FFmpeg concat 分离器，这种方法成功率很高，无损合并，但是需要 FFmpeg 1.1 以上版本。先创建一个文本文件filelist.txt： 123file &apos;input1.ts&apos;file &apos;input2.ts&apos;file &apos;input3.ts&apos; 然后： 1ffmpeg -f concat -i filelist.txt -c copy output.mkv 完整的代码12345678910111213141516171819202122232425262728import sysimport m3u8import requestsif len(sys.argv)&lt;2 : print('please input m3u8 uri') sys.exit()print('only download ts fragments, use ffmpeg to merge : ffmpeg -f concat -i filelist.txt -c copy moive.mkv') m3u8uri=sys.argv[1]p=m3u8.load(m3u8uri)s=p.segmentsl=len(s)filelist='filelist.txt'with open(filelist,'w') as flist: for i in range(0,l) : t=s[i] r=requests.get(t.absolute_uri) if r.status_code==200 : fname="%09d.ts" % (i+1) with open(fname,'wb') as f: f.write(r.content) flist.write( "file '%s' \n" % fname ) print('status: '+fname+'/'+str(l)+' is done') print('now use the cmd to merge the ts fragments :')print(' ffmpeg -f concat -i filelist.txt -c copy moive.mkv') 效果目前只是单线程顺序下载，浪费了大量的宽带。后期需要加入多线程加速。]]></content>
      <tags>
        <tag>ffmpeg</tag>
        <tag>hls</tag>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wireshark抓包rtsp]]></title>
    <url>%2F12892%2F</url>
    <content type="text"><![CDATA[项目需要用RTP/RTSP做视频直播，为了对RTSP协议有个直观的认识，我利用Wirshark和Npcap对RTSP数据包进行抓包分析。 工具软件简介驱动WinPcap 和 Npcap都是工业级的网络抓包工具，网络抓包基本都会用到。 由于很长一段时间WinPcap没有更新了，于是Npcap在它的基础上被开发出来 （但是WinPcap最近又更新了）。目前来看，WinPcap不能抓取本地回环地址（Loopback Address），即 127.0.0.1，Npcap可以。 前端Wireshark是非常好用的网络协议分析软件，它可以把Npcap抓取到的数据包按照各种协议解析，可视化非常棒。 操作过程建立rtsp服务器我用了两种方式： 使用Live555服务器。 “LIVE555 Media Server”是一个开源的RTSP服务器，使用很简单。单文件程序，将视频文件和程序放到同一个文件夹，运行程序就可以通过rtsp协议访问了，例如：rtsp://192.168.1.3:8554/demo.mp4。这种方式可以在同一个局域网中访问。 使用VLC播放器的流服务。 具体为选择 【媒体-&gt;流-&gt; 添加文件-&gt; 串流-&gt; 添加RTSP-&gt; 修改端口路径-&gt; 完善sdp地址】,最后得到一串这样的字符 :sout=#rtp{sdp=rtsp://localhost:8554/demo} :no-sout-all :sout-keep 。这种方式由于防火墙的限制，只能在本机使用。 抓取数据包 使用VLC流服务建立的rtsp服务器的方式。 VLC串流开始后，在打开一个VLC播放器，打开网络串流rtsp://localhost:8554/ 就会看到视频了。但注意，由于是本地回环地址抓包，因此Wireshark选择 Npcap Loopback Adapter 网卡输入(安装完Npcap会生成这个网卡) 这里只介绍使用 LIVE555 Media Server 的方式。打开Wireshark，选择电脑网卡，进入主界面会看到好多ip数据包，我们需要挑选出有用的。在过滤输入框内输入ip.addr==192.168.1.3（192.168.1.3是rtsp服务器的ip），这样就只会显示来自rtsp服务器的数据包。然后用VLC打开网络串流rtsp://192.168.1.3:8554/demo.mp4,就会抓取到rtsp数据包了。可以看到，开始建立链接的过程中，类似tcp三次握手的方式，相互确认。其中有一个步骤是服务器向客户端发送sdp描述文件RTSP/SDP协议。查看具体信息会发现有Media Description, name and address (m): video 0 RTP/AVP 96 和 Media Description, name and address (m): audio 0 RTP/AVP 97 分别表示视频流为负载96，音频流为负载97。这和RTP的SDP文件是一样的。也就说明了，RTSP协议会自动发送SDP文件，不用再去手动写一份SDP文件然后用VLC打开。 再往下看，会看到传输的数据，有两种负载类型96和97，从SDP描述信息已经知道96为视频流，所以可以把RTP包进一步解包，然后用H264解码；97为音频流，由于没有找到音频的解码协议，因此没有对RTP包进一步解码。 如果没有看到如上的结果，而是显示的是UDP协议，需要对UDP进一步解码，选中一个UDP包，右键选择解码为RTP即可。 从上面的结果可以看出，RTSP是靠RTSP/SDP传输SDP描述文件，靠RTP协议传输音视频数据，靠RTCP进行控制。 扩展 RTP MPEG_TS 包RTP服务器一般是直接把h264数据或ac3数据发送出去，客户端根据负载类型对数据进行解码。一般直播会选择这种方式，实时性好。 RTP还有另一种方式发送数据，就是把音频和视频封装到TS容器，然后再发送mpeg ts包。这样实际就是发送的一个完整的视频文件了,只是时间只有几秒而已。 可以把其保存到本地视频文件。保存为本地视频文件具体操作可参考wireshark wiki Wireshark extension to dump MPEG2 transport stream packets to file, removing the network headers and leaving just an MPEG2 transport stream. To use this script: Download the attachment mpeg_packets_dump.lua Save it in the Wireshark home directory e.g. c:\Program Files\Wireshark — as “mpeg_packets_dump.lua” Edit init.lua in the Wireshark home directory and add the following line: dofile(“mpeg_packets_dump.lua”) Restart Wireshark to add the extension Capture some traffic which includes some MPEG transport packets, for example, it has been tested with MPEG transmitted via UDP multicast. Stop the capture, and select Tools -&gt; Dump MPEG TS Packets Enter the file where the mpeg stream should be saved. In order to select only one of many streams, enter a wireshark filter — expression, or you can leave the filter blank. Press okay. Any MPEG packets in the current capture which were detected by the MPEG dissector and that match your filter will be dumped to your output file RTP MPEG_TS的方式是不需要SDP描述文件的，SDP描述文件的目的是告诉客户端对哪种类型的负载采用哪种解码方式。看看RTP报头可以发现 RTP协议用一个7bit数据表示负载类型，因此一共可以表示128种。具体可看RTP_payload_formats wiki 可以看到有一些类型是固定的。正如上图显示的负载类型为33，就表示这个RTP包的内容为封装为TS的音视频数据，客户端就可以按照mpeg ts解码了。如果使用的是96以上的负载类型，就需要写一个sdp文件告诉客户端怎么解码了。 ffmpeg命令行12345678910111213141516#提取视频：ffmpeg -i demo.mp4 -vcodec copy -an video.mp4#提取音频：ffmpeg -i demo.mp4 -acodec copy -vn Audio.mp3#rtp 推流ffmpeg -re -i video.mp4 -vcodec copy -f rtp rtp://127.0.0.1:1234ffmpeg -re -i Audio.mp3 -acodec copy -f rtp rtp://127.0.0.1:1235#rtp mpegts 推流ffmpeg -re -i demo.mp4 -vcodec copy -f rtp_mpegts rtp://127.0.0.1:1236# 推流到rtsp服务器ffmpeg -re -i demo.mp4 -rtsp_transport tcp -vcodec copy -f rtsp rtsp://rtsp/testffmpeg -re -i demo.mp4 -rtsp_transport udp -vcodec copy -f rtsp rtsp://rtsp/test wireshark插件在抓包RTP过程中，常常需要把视频数据保存到本地，我使用到了两个非常好用的插件，可以满足一般需求。分别是 h264_export.lua 和 mpeg_packets_dump.lua 。 安装方式，进入wireshark根目录，找到init.lua文件，在最后面添加两行dofile(&quot;mpeg_packets_dump.lua&quot;) dofile(&quot;h264_export.lua&quot;) ，然后把h264_export.lua 和 mpeg_packets_dump.lua文件放到根目录下即可。重启软件就能加载插件了。 h264_export.lua 把H264包保存为本地 .h264视频文件[项目地址] (https://github.com/seudut/h264_export) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460-- Dump RTP h.264 payload to raw h.264 file (*.264) -- According to RFC3984 to dissector H264 payload of RTP to NALU, and write it -- to from&lt;sourceIp_sourcePort&gt;to&lt;dstIp_dstPort&gt;.264 file. By now, we support single NALU, -- STAP-A and FU-A format RTP payload for H.264. -- You can access this feature by menu "Tools-&gt;Export H264 to file [HQX's plugins]" -- Author: Huang Qiangxiong (qiangxiong.huang@gmail.com) -- change log: -- 2012-03-13 -- Just can play -- 2012-04-28 -- Add local to local function, and add [local bit = require("bit")] to prevent -- bit recleared in previous file. -- 2013-07-11 -- Add sort RTP and drop uncompleted frame option. -- 2013-07-19 -- Do nothing when tap is triggered other than button event. -- Add check for first or last packs lost of one frame. -- 2014-10-23 -- Fixed bug about print a frame.nalu_type error. -- 2014-11-07 -- Add support for Lua 5.2(&gt;1.10.1) and 5.1(&lt;=1.10.1). -- Change range:string() to range:raw(). -- Change h264_f.value to h264_f.range:bytes() because of wireshark lua bug. -- 2015-06-03 -- Fixed bug that if ipv6 address is using the file will not generated.(we replace ':' to '.') -- 2017-08-18 -- Fixed bug on Mac with Wireshark 2.4.1, that error (Permission denied) happens when writing to file. -- Add check when open file, if failed, trying home directory instead of default directory -- (/Application/Wireshark.app/)------------------------------------------------------------------------------------------------ do --local bit = require("bit") -- only work before 1.10.1 --local bit = require("bit32") -- only work after 1.10.1 (only support in Lua 5.2) local version_str = string.match(_VERSION, "%d+[.]%d*") local version_num = version_str and tonumber(version_str) or 5.1 local bit = (version_num &gt;= 5.2) and require("bit32") or require("bit") -- for geting h264 data (the field's value is type of ByteArray) local f_h264 = Field.new("h264") local f_rtp = Field.new("rtp") local f_rtp_seq = Field.new("rtp.seq") local f_rtp_timestamp = Field.new("rtp.timestamp") local nalu_type_list = &#123; [0] = "Unspecified", [1] = "P/B_slice", [2] = "P/B_A", [3] = "P/B_B", [4] = "P/B_C", [5] = "I_slice", [6] = "SEI", [7] = "SPS", [8] = "PPS", [9] = "AUD", &#125; local function get_enum_name(list, index) local value = list[index] return value and value or "Unknown" end -- menu action. When you click "Tools-&gt;Export H264 to file [HQX's plugins]" will run this function local function export_h264_to_file() -- window for showing information local tw = TextWindow.new("Export H264 to File Info Win") --local pgtw = ProgDlg.new("Export H264 to File Process", "Dumping H264 data to file...") local pgtw; -- add message to information window function twappend(str) tw:append(str) tw:append("\n") end -- running first time for counting and finding sps+pps, second time for real saving local first_run = true -- variable for storing rtp stream and dumping parameters local stream_infos = nil -- drop_uncompleted_frame local drop_uncompleted_frame = false -- max frame buffer size local MAX_FRAME_NUM = 3 -- trigered by all h264 packats local my_h264_tap = Listener.new(tap, "h264") -- get rtp stream info by src and dst address function get_stream_info(pinfo) local key = "from_" .. tostring(pinfo.src) .. "_" .. tostring(pinfo.src_port) .. "to" .. tostring(pinfo.dst) .. "_" .. tostring(pinfo.dst_port) .. (drop_uncompleted_frame and "_dropped" or "_all") key = key:gsub(":", ".") local stream_info = stream_infos[key] if not stream_info then -- if not exists, create one stream_info = &#123; &#125; stream_info.filename = key.. ".264" stream_info.file, err= io.open(stream_info.filename, "wb") if stream_info.file == nil then twappend("*** Error - Could not open file: " .. err .. "\n") twappend("Trying the home directory... \n") stream_info.file, err= io.open( os.getenv("HOME") .. "/" .. stream_info.filename, "wb") if stream_info.file == nil then twappend("*** Error - :" .. err .. " \n") else twappend("*** Success - Open file : " .. os.getenv("HOME") .. "/" .. stream_info.filename .. " \n") end end stream_info.counter = 0 -- counting h264 total NALUs stream_info.counter2 = 0 -- for second time running stream_infos[key] = stream_info twappend("Ready to export H.264 data (RTP from " .. tostring(pinfo.src) .. ":" .. tostring(pinfo.src_port) .. " to " .. tostring(pinfo.dst) .. ":" .. tostring(pinfo.dst_port) .. " to file:\n [" .. stream_info.filename .. "] ...\n") end return stream_info end -- write a NALU or part of NALU to file. local function real_write_to_file(stream_info, str_bytes, begin_with_nalu_hdr) if first_run then stream_info.counter = stream_info.counter + 1 if begin_with_nalu_hdr then -- save SPS or PPS local nalu_type = bit.band(str_bytes:byte(0,1), 0x1F) if not stream_info.sps and nalu_type == 7 then stream_info.sps = str_bytes elseif not stream_info.pps and nalu_type == 8 then stream_info.pps = str_bytes end end else -- second time running --[[ if begin_with_nalu_hdr then -- drop AUD local nalu_type = bit.band(str_bytes:byte(0,1), 0x1F) if nalu_type == 9 then return; end end ]] if stream_info.counter2 == 0 then -- write SPS and PPS to file header first if stream_info.sps then stream_info.file:write("\00\00\00\01") stream_info.file:write(stream_info.sps) else twappend("Not found SPS for [" .. stream_info.filename .. "], it might not be played!\n") end if stream_info.pps then stream_info.file:write("\00\00\00\01") stream_info.file:write(stream_info.pps) else twappend("Not found PPS for [" .. stream_info.filename .. "], it might not be played!\n") end end if begin_with_nalu_hdr then -- *.264 raw file format seams that every nalu start with 0x00000001 stream_info.file:write("\00\00\00\01") end stream_info.file:write(str_bytes) stream_info.counter2 = stream_info.counter2 + 1 -- update progress window's progress bar if stream_info.counter &gt; 0 and stream_info.counter2 &lt; stream_info.counter then pgtw:update(stream_info.counter2 / stream_info.counter) end end end local function comp_pack(p1, p2) if math.abs(p2.seq - p1.seq) &lt; 1000 then return p1.seq &lt; p2.seq else -- seqeunce is over 2^16, so the small one is much big return p1.seq &gt; p2.seq end end local function print_seq_error(stream_info, str) if stream_info.seq_error_counter == nil then stream_info.seq_error_counter = 0 end stream_info.seq_error_counter = stream_info.seq_error_counter + 1 twappend(str .. " SeqErrCounts=" .. stream_info.seq_error_counter) end local function sort_and_write(stream_info, frame) table.sort(frame.packs, comp_pack) -- check if it is uncompleted frame local completed = true for i = 1, #frame.packs - 1, 1 do local seq1 = frame.packs[i].seq local seq2 = frame.packs[i+1].seq if bit.band(seq1+1, 0xFFFF) ~= seq2 then print_seq_error(stream_info, " RTP pack Lost: timestamp=" .. frame.timestamp .. " seq between " .. seq1 .. " and " .. seq2) completed = false end end if not frame.packs[1].nalu_begin then print_seq_error(stream_info, " RTP pack Lost: timestamp=" .. frame.timestamp .. " seq before " .. frame.packs[1].seq) completed = false end if not frame.packs[#frame.packs].nalu_end then print_seq_error(stream_info, " RTP pack Lost: timestamp=" .. frame.timestamp .. " seq after " .. frame.packs[#frame.packs].seq) completed = false end if completed then for i = 1, #frame.packs, 1 do real_write_to_file(stream_info, frame.packs[i].data, frame.packs[i].nalu_begin) end else twappend(" We drop one uncompleted frame: rtp.timestamp=" .. frame.timestamp .. " nalu_type=" .. (frame.nalu_type and frame.nalu_type .."(" .. get_enum_name(nalu_type_list, frame.nalu_type) .. ")" or "unknown") ) end end local function write_to_file(stream_info, str_bytes, begin_with_nalu_hdr, timestamp, seq, end_of_nalu) if drop_uncompleted_frame and not first_run then -- sort and drop uncompleted frame if stream_info.frame_buffer_size == nil then stream_info.frame_buffer_size = 0 end if timestamp &lt; 0 or seq &lt; 0 then twappend(" Invalid rtp timestamp (".. timestamp .. ") or seq (".. seq .. ")! We have to write it to file directly!") real_write_to_file(stream_info, str_bytes, begin_with_nalu_hdr) return; end -- check if this frame has existed local p = stream_info.frame_buffer while p do if p.timestamp == timestamp then break; else p = p.next end end if p then -- add this pack to frame if begin_with_nalu_hdr then p.nalu_type = bit.band(str_bytes:byte(1), 0x1F) end table.insert(p.packs, &#123; ["seq"] = seq, ["data"] = str_bytes , ["nalu_begin"] = begin_with_nalu_hdr, ["nalu_end"] = end_of_nalu &#125;) return end if stream_info.frame_buffer_size &gt;= MAX_FRAME_NUM then -- write the most early frame to file sort_and_write(stream_info, stream_info.frame_buffer) stream_info.frame_buffer = stream_info.frame_buffer.next stream_info.frame_buffer_size = stream_info.frame_buffer_size - 1 end -- create a new frame buffer for new frame (timestamp) local frame = &#123;&#125; frame.timestamp = timestamp if begin_with_nalu_hdr then frame.nalu_type = bit.band(str_bytes:byte(1), 0x1F) end frame.packs = &#123;&#123; ["seq"] = seq, ["data"] = str_bytes, ["nalu_begin"] = begin_with_nalu_hdr, ["nalu_end"] = end_of_nalu&#125;&#125; -- put pack to index 1 pos frame.next = nil if stream_info.frame_buffer_size == 0 then -- first frame stream_info.frame_buffer = frame else p = stream_info.frame_buffer while p.next do p = p.next end p.next = frame end stream_info.frame_buffer_size = stream_info.frame_buffer_size + 1 else -- write data direct to file without sort or frame drop real_write_to_file(stream_info, str_bytes, begin_with_nalu_hdr) end end -- read RFC3984 about single nalu/stap-a/fu-a H264 payload format of rtp -- single NALU: one rtp payload contains only NALU local function process_single_nalu(stream_info, h264, timestamp, seq) --write_to_file(stream_info, h264:tvb()():string(), true, timestamp, seq, true) write_to_file(stream_info, ((version_num &gt;= 5.2) and h264:tvb():raw() or h264:tvb()():string()), true, timestamp, seq, true) end -- STAP-A: one rtp payload contains more than one NALUs local function process_stap_a(stream_info, h264, timestamp, seq) local h264tvb = h264:tvb() local offset = 1 local i = 1 repeat local size = h264tvb(offset,2):uint() --write_to_file(stream_info, h264tvb(offset+2, size):string(), true, timestamp, i, true) write_to_file(stream_info, ((version_num &gt;= 5.2) and h264tvb:raw(offset+2, size) or h264tvb(offset+2, size):string()), true, timestamp, i, true) offset = offset + 2 + size i = i + 1 until offset &gt;= h264tvb:len() end -- FU-A: one rtp payload contains only one part of a NALU (might be begin, middle and end part of a NALU) local function process_fu_a(stream_info, h264, timestamp, seq) local h264tvb = h264:tvb() local fu_idr = h264:get_index(0) local fu_hdr = h264:get_index(1) local end_of_nalu = (bit.band(fu_hdr, 0x40) ~= 0) if bit.band(fu_hdr, 0x80) ~= 0 then -- start bit is set then save nalu header and body local nalu_hdr = bit.bor(bit.band(fu_idr, 0xE0), bit.band(fu_hdr, 0x1F)) --write_to_file(stream_info, string.char(nalu_hdr) .. h264tvb(2):string(), true, timestamp, seq, end_of_nalu) write_to_file(stream_info, string.char(nalu_hdr) .. ((version_num &gt;= 5.2) and h264tvb:raw(2) or h264tvb(2):string()), true, timestamp, seq, end_of_nalu) else -- start bit not set, just write part of nalu body --write_to_file(stream_info, h264tvb(2):string(), false, timestamp, seq, end_of_nalu) write_to_file(stream_info, ((version_num &gt;= 5.2) and h264tvb:raw(2) or h264tvb(2):string()), false, timestamp, seq, end_of_nalu) end end -- call this function if a packet contains h264 payload function my_h264_tap.packet(pinfo,tvb) if stream_infos == nil then -- not triggered by button event, so do nothing. return end local h264s = &#123; f_h264() &#125; -- using table because one packet may contains more than one RTP local rtps = &#123; f_rtp() &#125; local rtp_seqs = &#123; f_rtp_seq() &#125; local rtp_timestamps = &#123; f_rtp_timestamp() &#125; for i,h264_f in ipairs(h264s) do if h264_f.len &lt; 2 then return end --local h264 = h264_f.value -- is ByteArray, it only works for 1.10.1 or early version --local h264 = h264_f.range:bytes() -- according to user-guide.chm, there is a bug of fieldInfo.value, so we have to convert it to TVB range first local h264 = (version_num &gt;= 5.2) and h264_f.range:bytes() or h264_f.value local hdr_type = bit.band(h264:get_index(0), 0x1F) local stream_info = get_stream_info(pinfo) --twappend(string.format("hdr_type=%X %d", hdr_type, hdr_type)) --twappend("bytearray=" .. tostring(h264)) --twappend("byterange=" .. tostring(h264_f.range):upper()) -- search the RTP timestamp and sequence of this H264 local timestamp = -1 local seq = -1 -- debug begin local rtplen = -1 local preh264_foffset = -1 local prertp_foffset = -1 local preh264len = -1 -- debug end if drop_uncompleted_frame then local matchx = 0; for j,rtp_f in ipairs(rtps) do if h264_f.offset &gt; rtp_f.offset and h264_f.offset - rtp_f.offset &lt;= 16 and h264_f.offset+h264_f.len &lt;= rtp_f.offset+rtp_f.len then -- debug begin --if h264_f.offset &gt; rtp_f.offset and h264_f.offset &lt; rtp_f.offset+rtp_f.len then matchx = matchx + 1 if matchx &gt; 1 then print_seq_error(stream_info, "ASS seq=" .. seq .. " timestamp=" .. timestamp .. " rtplen=" .. rtplen .. " rtpoff=" .. prertp_foffset .. " h264off=" .. preh264_foffset .. " h264len=" .. preh264len .. " |matched=" .. matchx .. " New seq=" .. rtp_seqs[j].value .. " timestamp=" .. rtp_timestamps[j].value .. " rtplen=" .. rtp_f.len .." rtpoff=" .. rtp_f.offset .. " h264off=" .. h264_f.offset .. " h264.len=" .. h264_f.len) end -- debug end seq = rtp_seqs[j].value timestamp = rtp_timestamps[j].value -- debug begin rtplen = rtp_f.len preh264_foffset = h264_f.offset prertp_foffset = rtp_f.offset preh264len = h264_f.len -- debug end break end end end if hdr_type &gt; 0 and hdr_type &lt; 24 then -- Single NALU process_single_nalu(stream_info, h264, timestamp, seq) elseif hdr_type == 24 then -- STAP-A Single-time aggregation process_stap_a(stream_info, h264, timestamp, seq) elseif hdr_type == 28 then -- FU-A process_fu_a(stream_info, h264, timestamp, seq) else twappend("Error: unknown type=" .. hdr_type .. " ; we only know 1-23(Single NALU),24(STAP-A),28(FU-A)!") end end end -- close all open files local function close_all_files() if stream_infos then local no_streams = true for id,stream in pairs(stream_infos) do if stream and stream.file then if stream.frame_buffer then local p = stream.frame_buffer while p do sort_and_write(stream, p) p = p.next end stream.frame_buffer = nil stream.frame_buffer_size = 0 end stream.file:flush() stream.file:close() twappend("File [" .. stream.filename .. "] generated OK!\n") stream.file = nil no_streams = false end end if no_streams then twappend("Not found any H.264 over RTP streams!") end end end function my_h264_tap.reset() -- do nothing now end local function remove() my_h264_tap:remove() end tw:set_atclose(remove) local function export_h264(drop_frame) pgtw = ProgDlg.new("Export H264 to File Process", "Dumping H264 data to file...") first_run = true drop_uncompleted_frame = drop_frame stream_infos = &#123;&#125; -- first time it runs for counting h.264 packets and finding SPS and PPS retap_packets() first_run = false -- second time it runs for saving h264 data to target file. retap_packets() close_all_files() -- close progress window pgtw:close() stream_infos = nil end local function export_all() export_h264(false) end local function export_completed_frames() export_h264(true) end tw:add_button("Export All", export_all) tw:add_button("Export Completed Frames (Drop uncompleted frames)", export_completed_frames) end -- Find this feature in menu "Tools-&gt;"Export H264 to file [HQX's plugins]"" register_menu("Export H264 to file [HQX's plugins]", export_h264_to_file, MENU_TOOLS_UNSORTED) end mpeg_packets_dump.lua 将mpeg ts包保存为ts视频文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107-- Wireshark extension to dump MPEG2 transport stream packets---- To use this script:-- 1. Save it in the Wireshark home directory e.g. c:\Program Files\Wireshark-- 2. Edit init.lua in the Wireshark home directory and add the following line-- dofile("mpeg_packets_dump.lua")-- 3. Restart Wireshark to add the extension-- 4. Capture some traffic which includes some MPEG transport packets, for-- example, it has been tested with MPEG transmitted via UDP multicast.-- 5. Stop the capture, and select Tools -&gt; Dump MPEG TS Packets-- 6. Enter the file where the mpeg stream should be saved. -- 7. In order to select only one of many streams, enter a wireshark filter-- expression, or you can leave the filter blank.-- 8. Press okay. Any MPEG packets in the current capture which were detected -- by the MPEG dissector and that match your filter will be dumped to -- your output file.---- Tested with Wireshark 1.4.3-- ryan.gorsuch_at_echostar_com-- 2011-04-01-- Modified and tested with Wireshark 1.11.3-- hadrielk_at_yahoo_com-- 2014-02-17-- only works in wireshark, not tsharkif not GUI_ENABLED then print("mpeg_packets_dump.lua only works in Wireshark") returnend-- declare some field extractorslocal mpeg_pid = Field.new("mp2t.pid")local mpeg_pkt = Field.new("mp2t")-- declare some functions we define laterlocal tobinary-- do a payload dump when prompted by the userlocal function init_payload_dump(file,filter) local packet_count = 0 local tap = Listener.new(nil,filter) local myfile = assert(io.open(file, "w+b")) -- this function is going to be called once each time our filter matches function tap.packet(pinfo,tvb) if ( mpeg_pid() ) then packet_count = packet_count + 1 -- there can be multiple mp2t packets in a given frame, so get them all into a table local contents = &#123; mpeg_pkt() &#125; for i,finfo in ipairs(contents) do local tvbrange = finfo.range myfile:write( tobinary( tostring( tvbrange:bytes() ) ) ) myfile:flush() end end end -- re-inspect all the packets that are in the current capture, thereby -- triggering the above tap.packet function retap_packets() -- cleanup myfile:close() tap:remove() debug("Dumped mpeg packets: " .. packet_count )end-- show this dialog when the user select "Dump" from the Tools menulocal function begin_dialog_menu() new_dialog("Dump MPEG TS Packets",init_payload_dump,"Output file","Packet filter (optional)\n\nExamples:\nip.dst == 225.1.1.4\nmp2t\nmp2t.pid == 0x300")endregister_menu("Dump MPEG TS Packets",begin_dialog_menu,MENU_TOOLS_UNSORTED)local function hex(ascii_code) -- convert an ascii char code to an integer value "0" =&gt; 0, "1" =&gt; 1, etc if not ascii_code then return 0 elseif ascii_code &lt; 58 then return ascii_code - 48 elseif ascii_code &lt; 91 then return ascii_code - 65 + 10 else return ascii_code - 97 + 10 endendtobinary = function (hexbytes)-- this function converts a hex-string to raw bytes local binary = &#123;&#125; local sz = 1 for i=1, string.len(hexbytes), 2 do binary[sz] = string.char( 16 * hex( string.byte(hexbytes,i) ) + hex( string.byte(hexbytes,i+1) ) ) sz = sz + 1 end return table.concat(binary) end]]></content>
      <tags>
        <tag>Wireshark</tag>
        <tag>WinPcap</tag>
        <tag>Npcap</tag>
        <tag>RTSP</tag>
        <tag>RTP</tag>
        <tag>抓包</tag>
        <tag>Loopback</tag>
        <tag>mpeg_packets_dump.lua</tag>
        <tag>h264_export.lua</tag>
      </tags>
  </entry>
</search>
